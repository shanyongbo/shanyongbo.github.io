<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="yanm1ng&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      操作系统-持久性 | shan
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/css/plugins/gitment.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    
<script src="/js/qrious.js"></script>

  
  
    
<script src="/js/gitment.js"></script>

  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
<meta name="generator" content="Hexo 4.2.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>shan</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>操作系统-持久性</h2>
  <p class="post-date">2020-06-06</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>本文为操作系统导论中关于持久性部分的读书笔记。其中主要涉及I/O设备，文件系统等相关知识。</p>
<a id="more"></a>

<h1 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h1><p>I/O对于计算机系统非常重要，对于I/O主要有如下的问题：I/O该如何集成进入系统？一般机制是什么？如何让它变得高效？</p>
<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>下图展示了一个典型的系统架构，其中CPU通过某种<strong>内存总线（memory bus）</strong>或互联电缆连接到系统内存。图像或其他高性能I/O设备通过常规的<strong>I/O总线（I/O bus）</strong>连接到系统，现代系统中一般是PCI或其延伸形式。最后是<strong>外设总线（peripheral bus）</strong>，如SCSI、SATA或USB，它们将最慢的设备连接至系统，如磁盘、鼠标及其他类设备。这样分层的目的是为了物理布局及造价成本，越快的总线越短，无法连接太多设备，并且造价高。</p>
<img src="/2020/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%8C%81%E4%B9%85%E6%80%A7/原型系统架构.png" alt="image-20200606101547485" style="zoom: 25%;">





<h2 id="标准设备"><a href="#标准设备" class="headerlink" title="标准设备"></a>标准设备</h2><p>下面通过一个标准设备更好的理解设备交互的机制。从下图可以看到，一个包含两部分重要组件的设备。</p>
<p>第一部分是向系统其他部分展现的<strong>硬件接口（interface）</strong>，和软件一样，硬件也需要接口，让系统软件来控制它的操作，因此，所有设备都有自己特定接口以及典型交互的协议。</p>
<p>第二部分是它的<strong>内部结构（internal structure）</strong>。这部分包含设备相关的特定实现，负责具体实现设备展示给系统的抽象接口。</p>
<img src="/2020/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%8C%81%E4%B9%85%E6%80%A7/标准设备.png" alt="image-20200606125130513" style="zoom: 33%;">





<h2 id="标准协议"><a href="#标准协议" class="headerlink" title="标准协议"></a>标准协议</h2><p>在上面的图中可以看到，一个设备接口包含3个寄存器：</p>
<ul>
<li>一个状态寄存器(status)，可以读取并查看设备当前状态；</li>
<li>一个命令寄存器(command)，用于通知设备某个具体任务；</li>
<li>一个数据寄存器(data)，将数据传给设备或者从设备接收数据。</li>
</ul>
<p>下面伪代码描述操作系统与该设备的交互：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (STATUS &#x3D;&#x3D; BUSY)</span><br><span class="line">    ; &#x2F;&#x2F; 等待，直到设备不忙</span><br><span class="line">&#x2F;&#x2F;将数据写入数据寄存器</span><br><span class="line">&#x2F;&#x2F;将命令写入命令寄存器</span><br><span class="line">&#x2F;&#x2F;开启设备并且执行命令</span><br><span class="line">while(STATUS &#x3D;&#x3D; BUSY)</span><br><span class="line">    ; &#x2F;&#x2F;等待直到设备做完了你的请求</span><br></pre></td></tr></table></figure>

<p>上面描述的协议包含四步：</p>
<ol>
<li>操作系统通过反复读取状态寄存器，等待设备进入可以接受命令的就绪装态。称之为轮询（polling）设备。</li>
<li>操作系统下发数据到数据寄存器。如果CPU主动参与数据移动，称之为编程的I/O（PIO）。</li>
<li>操作系统将命令写入命令寄存器，这样设备就知道数据已完成准备，并开始执行。</li>
<li>操作系统轮询设备，等待并判断设备是否已经完成。</li>
</ol>
<h2 id="利用中断减少CPU开销"><a href="#利用中断减少CPU开销" class="headerlink" title="利用中断减少CPU开销"></a>利用中断减少CPU开销</h2><p>对于CPU的轮询可以使用中断来减少CPU的开销。有了中断以后，CPU不在需要不断轮询设备，而是向设备发出一个请求，然后就可以让对应进程睡眠，切换执行其他任务。当设备完成了自身操作，会抛出一个硬件中断，引发CPU跳转执行操作系统预先定义好的<strong>中断服务例程（Interrupt Service Routine，ISR）</strong>，或更为简单的<strong>中断处理程序（interrupt handler）</strong>。中断处理程序是一小段操作系统代码，它会结束之前的请求，并且唤醒等待I/O的进程继续执行。</p>
<p>因此<strong>中断允许计算与I/O重叠（overlap），这是提高CPU利用率的关键</strong>。但是如果设备性能非常高，使用中断，可能导致系统变慢。</p>
<p>如果设备性能未知，可以考虑使用<strong>混合策略（hybrid）</strong>。先尝试轮询一小段时间，如果设备没有完成操作，此时在使用中断，这种两阶段的办法可以实现两种方法的好处。</p>
<p>另一个基于中断的优化就是<strong>合并（coalescing）</strong>。设备在抛出中断之前往往会等待一小段时间，在此期间，其他请求可能很快完成，多个中断可以合并为一次中断抛出，从而降低处理中断的代价。</p>
<h2 id="利用DMA进行高效的数据传送"><a href="#利用DMA进行高效的数据传送" class="headerlink" title="利用DMA进行高效的数据传送"></a>利用DMA进行高效的数据传送</h2><p>如果使用编程的I/O将一大块数据传送给设备，CPU又会因为琐碎的任务而变得负载很重，浪费了时间和算力，本来更好是用于运行其他进程。使用PIO 的方式，CPU 的时间会浪费在向设备传输数据或从设备传出数据的过程中。如何才能分离这项工作，从而提高CPU 的利用率？</p>
<p>解决方案就是使用<strong>DMA（Direct Memory Access）</strong>，DMA引擎是系统中的一个特殊设备，它可以协调完成内存和设备之间的数据传递，不需要CPU的介入。其工作流程如下：为了能将数据传送给设备，操作系统会通过编程告诉DMA引擎数据在内存中的位置，要拷贝的大小以及拷贝到哪个设备。之后，操作系统可以处理其它请求了，当DMA的任务完成后，DMA控制器会抛出一个中断来告诉操作系统自己已经完成了数据传输。</p>
<h2 id="设备交互的方法"><a href="#设备交互的方法" class="headerlink" title="设备交互的方法"></a>设备交互的方法</h2><p>只要有两种方式实现与设备的交互：</p>
<ol>
<li><strong>用明确的I/O指令</strong>，这些指令规定了操作系统将数据发送到特定设备寄存器的方法，从而允许构造上文提到的协议。这些指令通常是特权指令（privileged），操作系统是唯一可以直接与设备交互的实体。</li>
<li><strong>内存映射I/O（memory-mapped I/O）</strong>，通过这种方式，硬件将设备寄存器作为内存地址提供。当需要访问硬件设备寄存器时，操作系统装载或者存入到该内存地址，然后硬件会将装载/存入转移到设备上，而不是物理内存。</li>
</ol>
<h2 id="将设备纳入操作系统"><a href="#将设备纳入操作系统" class="headerlink" title="将设备纳入操作系统"></a>将设备纳入操作系统</h2><p>可以通过<strong>抽象（abstraction）技术</strong>来解决。在最底层，操作系统的一部分软件清楚地知道设备如何工作，我们将这部分软件称为<strong>设备驱动程序（device driver）</strong>，所有设备交互的细节都封装在其中。</p>
<p>这种封装有一些不做，如，假设一个设备可以提供很多特殊的功能，但是为了兼容大多数操作系统它不得不提供一个通用的接口，这样就使得自身的特殊功能无法使用。</p>
<h1 id="磁盘驱动器"><a href="#磁盘驱动器" class="headerlink" title="磁盘驱动器"></a>磁盘驱动器</h1><p>磁盘驱动器在过去数十年来一直是计算机系统持久数据存储的主要形式，文件系统技术的大部分发展都是基于它们的行为。因此，在构建管理它的文件系统软件之前，需要先了解磁盘操作的细节。那么问题是：现代磁盘驱动程序是如何存储数据的？接口是什么？数据如何安排和访问的，磁盘调度如何提高性能。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>驱动器是由大量扇区（512字节块）组成，每个扇区都可以读取或者写入，在具有n个扇区的磁盘上，扇区从0到n-1编号。因此我们可以将磁盘视为一组扇区，0到n-1是驱动器的地址空间。多扇区操作是可行的，许多文件系统一次读取或者写入4KB或者更多。但在更新磁盘时，需要保证单个512字节的写入是原子的。</p>
<h2 id="基本几何形状"><a href="#基本几何形状" class="headerlink" title="基本几何形状"></a>基本几何形状</h2><p>一个磁盘由多个<strong>盘片（platter）</strong>组成，每个盘片有两面，每个面都称为表面。</p>
<p>所有的盘片都围绕<strong>主轴（spindle）</strong>连接到一起，主轴连接到一个电机，以一个恒定的速度旋转盘片。旋转速度通常以每分钟转数（Rotations Per Minute， RPM）来测量。</p>
<p>数据在扇区的同心圆中的每个表面上被编码，我们称这样的同心圆为一个<strong>磁道（track）</strong>。一个表面有数以千计的磁道，彼此紧密排在一起。</p>
<p>要从表面进行读写操作，我们需要一种机制，使我们能够感应磁盘上的磁性图案，或者让他们发生变化。读写由<strong>磁头（disk head）</strong>完成；驱动器表面有一个这样的磁头。磁头连接到单个<strong>磁盘臂（disk arm）</strong>上，磁盘臂在表面上移动，将磁头定位在期望的磁道上。</p>
<h2 id="I-O-时间"><a href="#I-O-时间" class="headerlink" title="I/O 时间"></a>I/O 时间</h2><p>磁盘读写主要包含以下类型的延迟时间：</p>
<ul>
<li>旋转延迟（rotational delay）</li>
<li>寻道时间（seek）</li>
<li>传输（transfer）</li>
</ul>
<p>一个磁盘的I/O时间通常用以下形成表示：<br>$$<br>T_{I/O} = T_{寻道} + T_{旋转} + T_{传输}<br>$$<br>那么驱动器I/O速率为：<br>$$<br>R_{I/O} = \frac{SIZE_{传输}}{T_{I/O}}<br>$$</p>
<h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><p>由于I/O 的高成本，操作系统在决定发送给磁盘的I/O 顺序方面历来发挥作用。更具体地说，给定一组I/O 请求，磁盘调度程序检查请求并决定下一个要调度的请求。</p>
<p>与任务调度不同，每个任务的长度通常是不知道的，对于磁盘调度，我们可以很好地猜测“任务”（即磁盘请求）需要多长时间。通过估计请求的查找和可能的旋转延迟，磁盘调度程序可以知道每个请求将花费多长时间，因此（贪婪地）选择先服务花费最少时间的请求。因此，磁盘调度程序将尝试在其操作中遵循<strong>SJF（最短任务优先）</strong>的原则（principle of SJF，shortest job first）。</p>
<h3 id="SSTF"><a href="#SSTF" class="headerlink" title="SSTF"></a>SSTF</h3><p>SSTF ：一种早期的磁盘调度方法，被称为<strong>最短寻道时间优先</strong>，Shortest-Seek-Time-First。SSTF 按磁道对I/O 请求队列排序，选择在最近磁道上的请求先完成。</p>
<h3 id="电梯：SCAN"><a href="#电梯：SCAN" class="headerlink" title="电梯：SCAN"></a>电梯：SCAN</h3><p>简单地以跨越磁道的顺序来服务磁盘请求。我们将一次跨越磁盘称为扫一遍。因此，如果请求的块所属的磁道在这次扫一遍中已经服务过了，它就不会立即处<br>理，而是排队等待下次扫一遍。</p>
<h3 id="SPTF"><a href="#SPTF" class="headerlink" title="SPTF"></a>SPTF</h3><p><strong>最短定位时间优先调度</strong>，Shortest Positioning Time First，SPTF，有时也称为最短接入时间优先，Shortest Access Time First，SATF。</p>
<h1 id="廉价冗余磁盘阵列"><a href="#廉价冗余磁盘阵列" class="headerlink" title="廉价冗余磁盘阵列"></a>廉价冗余磁盘阵列</h1><p>在整个计算机系统中，I/O操作是很慢的，它会成为整个系统的瓶颈。那么我们如何构建一个大型的、快速的、可靠的存储系统？</p>
<p>这里用的主要手段是<strong>廉价冗余磁盘阵列</strong>：Redundant Array of Inexpensive Disk，更多时候称为<strong>RAID</strong>，这种技术使用多个磁盘一起构建更大、更快、更可靠的磁盘系统。从外部来看，RAID看起来像是一个磁盘，一组可以读取或者写入的块。在内部，它是由多个磁盘、内存以及一个或多个处理器来管理的系统。</p>
<p>RAID与单个磁盘相比，有许多的优点：</p>
<ul>
<li>提高性能，并行使用多个磁盘可以大大加快I/O时间；</li>
<li>高容量，大型数据集需要 大型磁盘；</li>
<li>提高可靠性，在多个磁盘上传输数据会使数据易受到单个磁盘丢失的影响。</li>
</ul>
<p><strong>映射问题</strong>：这个问题出现在所有的RAID阵列中，简单的说，就是<strong>给定一个逻辑块来读或者写，RAID如何确切知道要访问哪个物理磁盘和偏移量？</strong></p>
<p><strong>RAID 一致性问题</strong>：一些特殊情况（如掉电）会导致数据块在连个副本中不一致，其一般解决方案是：使用某种<strong>预写日志（write-ahead log）</strong>，在做之前首先记录RAID 将要执行的操作（即用某个数据更新两个磁盘）。通过采取这种方法，我们可以确保在发生崩溃时，会发生正确的事情。通过运行一个恢复（recovery）过程，将所有未完成的事务重新在RAID 上执行，我们可以确保两个镜像副本（在RAID-1 情况下）同步。</p>
<p>根据容量、可靠性、性能三个方面评估 RAID 设计：</p>
<ul>
<li><strong>RAID 0级</strong>，条带化，没有冗余，以轮转方式将磁盘阵列的块分布在磁盘上。这种方法的目的是在对数组的连续块进行请求时，从阵列中获取最大的并行性。其容量和性能都是顶级的，但是任何磁盘故障都会导致有用数据丢失。</li>
<li><strong>RAID 1级</strong>，镜像，只需生成系统中每个块的多个副本，每个副本单独放在一个单独的磁盘上，其允许磁盘故障，这个其镜像级别有关。容量只有有用容量的1/n，其顺序读取和写入的性能只有最大带宽的1/n；其随机读取的性能为完整的带宽，随机写入的性能为1/n;<ul>
<li>RAID-10使用镜像对其生成副本，使用条带化增强性能与容量。</li>
<li>RAID-01包含两个大型条带化阵列，然后对其进行镜像。</li>
</ul>
</li>
<li><strong>RAID 4级</strong>，基于奇偶校验的冗余，这种方式试图以减小的容量解决副本问题，对条带中每块的每一位进行奇偶校验，填入对应的位置，这么做的代价是性能。其容量为N(磁盘数) - 1；其允许一个磁盘故障；其连续读取性能为 N - 1，顺序写入的性能为N-1(全条带写入)，随机读取的性能为N-1，小的随机写入性能为R/2；</li>
<li><strong>RAID 5级</strong>，旋转奇偶校验，每个条带奇偶校验都在磁盘上旋转，以消除RAID-4的奇偶校验盘的瓶颈。性能基本与RAID-4相同，其随机读取稍微好一点（可以利用所有磁盘），随机写入性能明显提高，因为它能够跨请求进行并行处理，为NR/4。因为它与RAID-4 基本相同，部分情况完全好于RAID-4，故基本上已经取代了RAID-4。</li>
</ul>
<p>其性能比较如下表所示，其中假设共有N块磁盘，连续工作负载下以S MB/s 传输数据，并且在随机工作负载下以R MB/s 传输数据：</p>
<table>
<thead>
<tr>
<th></th>
<th>RAID-0</th>
<th>RAID-1</th>
<th>RAID-4</th>
<th>RAID-5</th>
</tr>
</thead>
<tbody><tr>
<td>容量</td>
<td>N</td>
<td>N/2</td>
<td>N-1</td>
<td>N-1</td>
</tr>
<tr>
<td>可靠性</td>
<td>0</td>
<td>1(肯定) / N/2(运气)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>顺序读</td>
<td>N * S</td>
<td>N/2 * S</td>
<td>(N -1) * S</td>
<td>(N -1) * S</td>
</tr>
<tr>
<td>顺序写</td>
<td>N * S</td>
<td>N/2 * S</td>
<td>(N -1) * S</td>
<td>(N -1) * S</td>
</tr>
<tr>
<td>随机读</td>
<td>N * R</td>
<td>N * R</td>
<td>(N -1) * R</td>
<td>N * R</td>
</tr>
<tr>
<td>随机写</td>
<td>N * R</td>
<td>N/2 * R</td>
<td>1/2 * R</td>
<td>N/4 * R</td>
</tr>
<tr>
<td>读延迟</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>T</td>
</tr>
<tr>
<td>写延迟</td>
<td>T</td>
<td>T</td>
<td>2T</td>
<td>2T</td>
</tr>
</tbody></table>
<h1 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h1></section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#操作系统" >
    <span class="tag-code">操作系统</span>
  </a>

  <a href="/tags#持久性" >
    <span class="tag-code">持久性</span>
  </a>

  <a href="/tags#I/O设备" >
    <span class="tag-code">I/O设备</span>
  </a>

  <a href="/tags#文件系统" >
    <span class="tag-code">文件系统</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2020/05/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%B9%B6%E5%8F%91/">
        <span class="nav-arrow">← </span>
        
          操作系统-并发
        
      </a>
    
    
      <a class="nav-right" href="/2020/06/06/2020-06-06-%E5%88%A9%E7%94%A8%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/">
        
          利用二叉堆实现优先级队列
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#I-O设备"><span class="toc-nav-text">I&#x2F;O设备</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#系统架构"><span class="toc-nav-text">系统架构</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#标准设备"><span class="toc-nav-text">标准设备</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#标准协议"><span class="toc-nav-text">标准协议</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#利用中断减少CPU开销"><span class="toc-nav-text">利用中断减少CPU开销</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#利用DMA进行高效的数据传送"><span class="toc-nav-text">利用DMA进行高效的数据传送</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#设备交互的方法"><span class="toc-nav-text">设备交互的方法</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#将设备纳入操作系统"><span class="toc-nav-text">将设备纳入操作系统</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#磁盘驱动器"><span class="toc-nav-text">磁盘驱动器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#接口"><span class="toc-nav-text">接口</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#基本几何形状"><span class="toc-nav-text">基本几何形状</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#I-O-时间"><span class="toc-nav-text">I&#x2F;O 时间</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#磁盘调度"><span class="toc-nav-text">磁盘调度</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#SSTF"><span class="toc-nav-text">SSTF</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#电梯：SCAN"><span class="toc-nav-text">电梯：SCAN</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#SPTF"><span class="toc-nav-text">SPTF</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#廉价冗余磁盘阵列"><span class="toc-nav-text">廉价冗余磁盘阵列</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#文件和目录"><span class="toc-nav-text">文件和目录</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://shanyongbo.github.io/2020/06/06/操作系统-持久性/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>



  <script>
    var gitmentConfig = "yanm1ng";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "操作系统-持久性",
        owner: "yanm1ng",
        repo: "yanm1ng.github.io",
        oauth: {
          client_id: "0f87e490e00ee3fd87ef",
          client_secret: "4a9d2b148e7971c2201ad12131ce8bf8159ccd2e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  </script>




    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2020 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng" target="_blank" rel="noopener">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>

  </body>
</html>