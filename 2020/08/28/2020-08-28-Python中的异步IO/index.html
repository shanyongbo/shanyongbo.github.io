<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="yanm1ng&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Python中的异步IO | shan
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/css/plugins/gitment.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    
<script src="/js/qrious.js"></script>

  
  
    
<script src="/js/gitment.js"></script>

  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
<meta name="generator" content="Hexo 4.2.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>shan</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>Python中的异步IO</h2>
  <p class="post-date">2020-08-28</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>原文链接：<a href="https://realpython.com/async-io-python/#async-io-design-patterns" target="_blank" rel="noopener">Async IO in Python: A Complete Walkthrough</a></p>
<h2 id="Setting-Up-Your-Environment"><a href="#Setting-Up-Your-Environment" class="headerlink" title="Setting Up Your Environment"></a>Setting Up Your Environment</h2><p>You’ll need Python 3.7 or above to follow this article in its entirety, as well as the <code>aiohttp</code> and <code>aiofiles</code> packages:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python3.7 -m venv .&#x2F;py37async</span><br><span class="line">$ source .&#x2F;py37async&#x2F;bin&#x2F;activate  # Windows: .\py37async\Scripts\activate.bat</span><br><span class="line">$ pip install --upgrade pip aiohttp aiofiles  # Optional: aiodns</span><br></pre></td></tr></table></figure>

<h2 id="The-10-000-Foot-View-of-Async-IO"><a href="#The-10-000-Foot-View-of-Async-IO" class="headerlink" title="The 10,000-Foot View of Async IO"></a>The 10,000-Foot View of Async IO</h2><p>相比于久经考验的多进程和线程来说，Async IO 更少为人所知。这个小节会告诉你 async IO 是什么以及它所适用的环境。</p>
<h3 id="Where-Does-Async-IO-Fit-In"><a href="#Where-Does-Async-IO-Fit-In" class="headerlink" title="Where Does Async IO Fit In?"></a>Where Does Async IO Fit In?</h3><p>并发和并行是非常难以涉及的主题。这篇文章聚焦于<strong>异步 IO（Async IO）</strong>以及它在 Python 中的实现，花费一点时间去比较异步 IO 和一些类似的概念是值得的，以了解异步 IO 如何适应大的，有时令人头晕的问题。</p>
<p><strong>并行（Parallelism）</strong>：可以同时执行多项操作。<strong>多进程（Multiprocessing）</strong>是实现并行的一种手段，它将任务分散到各个计算机的中央处理单元（CPUs）。多进程非常适合 CPU 相关的任务：例如 for 循环和数学相关的计算。</p>
<p><strong>并发（Concurrency）</strong>：是一个比并行更加宽泛的概念。这表明多个任务具有以重叠方式运行的能力。<strong>线程（Threading）</strong>是一种并发执行模型，其中多个线程轮流执行任务。一个进程可以包含多个线程。由于<a href="https://realpython.com/python-gil/" target="_blank" rel="noopener">GIL</a>，Python 与线程之间的关系非常复杂，但这超出了本文的范围。</p>
<p>重要的是要知道线程化对于 IO 相关的任务来说更好。CPU 密集型任务的特征是计算机内核从头到尾都在不断地努力工作，而 IO 相关的工作主要由大量等待输入/输出才能完成。</p>
<p>综上所述，并发包括多进程（理想的是 CPU 相关的任务）和线程（适用于IO 相关的任务）。多进程是并行的一种形式，并行是并发的特定类型（子集）。<br>Python通过它的 <code>multiprocessing</code>，<code>threading</code> 和 <code>concurrent.futures</code> 等标准库对此提供了长期的的支持。</p>
<p>在过去的几年中，CPython 中更加全面地构建了单独的设计：异步 IO，它通过标准库的 asyncio 包以及新的 async 和 await 语言关键字而启用。需要明确的是，异步IO不是一个新发明的概念，它已经存在或正在其他语言和运行时环境中构建，例如<a href="https://gobyexample.com/goroutines" target="_blank" rel="noopener">Go</a>，<a href="https//docs.microsoft.com/zh-cn/dotnet/csharp/async">C＃</a>或<a href="https://docs.scala-lang.org/sips/async.html" target="_blank" rel="noopener">Scala</a>。</p>
<p>Python文档将 <code>asyncio</code> 这个包标记为<a href="https://docs.python.org/3/library/asyncio.html" target="_blank" rel="noopener">编写并发代码的库</a>。但是，异步 IO 既不是线程化的，也不是多进程的，它不是建立在这两个之上的。</p>
<p>事实上，异步 IO 是一个单线程单进程的设计：它使用的是合作的多任务（cooperative multitasking）。换句话说，虽然异步 IO 使用单进程单线程，但是它给人一种并发执行的感觉。<del>协程（异步 IO 的核心特征）可以调度并发，但他们不是内部的并发。</del></p>
<p>再次声明，异步 IO 是并发编程的一种方式，但是它不是并行的，与多进程相比，它与线程更加紧密地结合在一起，但两者却是截然不同的。</p>
<p>那么对于某些东西是异步的这种说法是什么意思？这并不是一个严格意义上的定义，但是对于我们这里的目的来说，我认为有两点属性：</p>
<ul>
<li>异步例程可以在等待其最终结果的同时”暂停“并让其他例程同时运行。 </li>
<li>通过上述机制，异步代码有助于并发执行。换句话说，异步代码给出了并发的外观。</li>
</ul>
<p>这里有张图把上述的概念放在了一起。白色的代表概念，绿色的代表实现的方式：</p>
<img src="/2020/08/28/2020-08-28-Python%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5IO/parallelism-concurrency.jpg">

<p>接下来我不在进行并发编程模型之间的比较。本教程重点介绍作为异步IO的子组件，如何使用它以及随之而来的API。要全面了解线程，多进程和异步IO，请在此处暂停并查看 Jim Anderson 的 <a href="https://realpython.com/python-concurrency/" target="_blank" rel="noopener">overview of concurrency in Python</a>。</p>
<h3 id="Async-IO-Explained"><a href="#Async-IO-Explained" class="headerlink" title="Async IO Explained"></a>Async IO Explained</h3><p>异步 IO 一开始看可能是反直觉的和自相矛盾的。使用单核单线程去促进并发？我从来都不擅长制作示例，因此我会解释一个2017 年 PyCon 上 Miguel Grinberg 的演讲，它十分完美的解释了这些：</p>
<blockquote>
<p>国际象棋大师 Judit Polgár 举办一个象棋展览，在这个展览上她扮演多个玩家角色，她有两种方式去组织这个展览：同步和异步。</p>
<p>假设：</p>
<ul>
<li>24 个对手</li>
<li>Judit 在 5 秒钟内移动棋子</li>
<li>对手花费 55 秒去移动棋子</li>
<li>游戏平均30对动作（总共60个动作）</li>
</ul>
<p>同步版本：Judit 每次只能进行一个游戏，从来不进行两个及以上的游戏；每个游戏花费 (55 + 5) * 30 == 1800 seconds，或者30分钟。整个展示花费24*30==720minutes，或者说 12 个小时。</p>
<p>异步版本：Judit 从一个桌子到另一个桌子，然后从中移动其中的一个棋子。她在等待对手进行下一步移动的时候离开桌子。在24个游戏上的每步移动花费Judit 24 * 5 == 120 seconds，或者说2分钟。整个展览现在需要花费120*30==3600s，或者说1个小时。</p>
</blockquote>
<p>Judit Polgár 只有一个，她有两只手并且每次只能移动一步。但是异步的进行游戏会将时间从12个小时降低为1个小时。因此，协作式多任务处理是一种有趣的说法，即程序的事件循环（稍后会详细介绍）与多个任务进行通信，以使每个任务在最佳时间轮流运行。</p>
<p>异步 IO 需要较长的等待时间，否则功能将会被阻塞，并允许其他功能在停机期间运行。 </p>
<h3 id="Async-IO-Is-Not-Easy"><a href="#Async-IO-Is-Not-Easy" class="headerlink" title="Async IO Is Not Easy"></a>Async IO Is Not Easy</h3><p>我听过下面一句话：尽可能的使用异步 IO，必要时使用线程。事实是，构建持久的多线程代码可能很困难并且容易出错。异步 IO 可以避免线程设计可能会遇到的某些潜在的速度起伏。</p>
<p>但是这并不能说明在Python中使用异步 IO就十分容易。请注意：当你冒险进入更加底层的时候，异步编程也可能变的十分困难！Python 的异步模型是基于诸如回调，事件，传输，协议和 futures 之类的概念构建的。其 API 不断变化的事实使其变得不那么容易。</p>
<p>幸运的是，<code>asyncio</code> 已经发展到其大部分功能不再是临时的状态，而其文档已得到了巨大的改进，与此相关的一些优质资源也开始出现。</p>
<h2 id="The-asyncio-Package-and-async-await"><a href="#The-asyncio-Package-and-async-await" class="headerlink" title="The asyncio Package and async/await"></a>The <code>asyncio</code> Package and <code>async</code>/<code>await</code></h2><p>现在，你已经对异步IO作为设计有了一定的了解，让我们来探讨 Python 的实现。Python的 <code>asyncio</code> 库（在Python 3.4中引入）及其两个关键字<code>async</code>和<code>await</code>具有不同的用途，但可以一起帮助你声明，构建，执行和管理异步代码。</p>
<h3 id="The-async-await-Syntax-and-Native-Coroutines"><a href="#The-async-await-Syntax-and-Native-Coroutines" class="headerlink" title="The async/await Syntax and Native Coroutines"></a>The <code>async</code>/<code>await</code> Syntax and Native Coroutines</h3><p><strong>警告</strong>：请注意你在 Internet 上阅读的内容。 Python 的异步 IO API 已从 Python 3.4 迅速发展到 Python 3.7 。某些旧的模块不再被使用，现在介绍一些最初被禁止的但现在允许的一些功能。就我所知，本教程也将很快过时。</p>
<p>异步 IO 的核心是协程。协程是 Python 生成器函数的专用版本。让我们从基准的定义开始，然后逐步构建：协程是一种函数，可以在达到 <code>return</code> 之前暂停其执行，并且可以在一段时间内间接将控制权传递给另一个协程。</p>
<p>之后，你将深入研究如何将传统的生成器准确地用于协程。目前，了解协程工作方式的最简单方法是开始编写一些协程的代码。</p>
<p>让我们采用沉浸式的方法并编写一些异步 IO 代码。这个简短的程序是异步IO的<code>Hello World</code>，但是在解释其核心功能方面还有很长的路要走：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># countasync.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"One"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"Two"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(count(), count(), count())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    s = time.perf_counter()</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    elapsed = time.perf_counter() - s</span><br><span class="line">    print(<span class="string">f"<span class="subst">&#123;__file__&#125;</span> executed in <span class="subst">&#123;elapsed:<span class="number">0.2</span>f&#125;</span> seconds."</span>)</span><br></pre></td></tr></table></figure>

<p>当你执行这个文件的时候，记录一下它和你仅仅使用 <code>def</code> 和 <code>time.sleep</code>() 定义的函数有什么不同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python3 countasync.py</span><br><span class="line">One</span><br><span class="line">One</span><br><span class="line">One</span><br><span class="line">Two</span><br><span class="line">Two</span><br><span class="line">Two</span><br><span class="line">countasync.py executed <span class="keyword">in</span> <span class="number">1.01</span> seconds.</span><br></pre></td></tr></table></figure>

<p>这个输出的顺序就是异步IO的核心。与每个对 <code>count</code>() 的调用进行通信的都是一个单一的事件循环或协调器。当每个任务到达 <code>await asyncio.sleep(1)</code> 时，该函数会告诉事件循环：“我要去sleeping 1 秒，继续让其他有意义的事情同时进行。”，然后将程序的控制权交给事件循环。</p>
<p>下面是同步的版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># countsync.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"One"</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"Two"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        count()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s = time.perf_counter()</span><br><span class="line">    main()</span><br><span class="line">    elapsed = time.perf_counter() - s</span><br><span class="line">    print(<span class="string">f"<span class="subst">&#123;__file__&#125;</span> executed in <span class="subst">&#123;elapsed:<span class="number">0.2</span>f&#125;</span> seconds."</span>)</span><br></pre></td></tr></table></figure>

<p>When executed, there is a slight but critical change in order and execution time:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python3 countsync.py</span><br><span class="line">One</span><br><span class="line">Two</span><br><span class="line">One</span><br><span class="line">Two</span><br><span class="line">One</span><br><span class="line">Two</span><br><span class="line">countsync.py executed <span class="keyword">in</span> <span class="number">3.01</span> seconds.</span><br></pre></td></tr></table></figure>

<p>使用 <code>time.sleep()</code>和<code>asyncio.sleep()</code>可能非常平淡无奇，但是它们通常代表任何的耗时程序等待时间的过程。也就是说，<code>time.sleep()</code> 可以表示任何耗时的阻塞函数调用，而 <code>asyncio.sleep()</code> 则用于代表非阻塞的调用（但也需要一些时间才能完成）。 </p>
<p>正如你在下面的章节所看见的那样，<code>await</code> 诸如 <code>asyncio.sleep()</code> 之类的事情的好处是，当前函数可以暂时将控制权让给另一个更容易立即执行某项功能的函数。相比之下，<code>time.sleep()</code> 或者其他阻塞的调用与异步 Python 代码不兼容，因为它会在睡眠时间内停止所有内容。</p>
<h3 id="The-Rules-of-Async-IO"><a href="#The-Rules-of-Async-IO" class="headerlink" title="The Rules of Async IO"></a>The Rules of Async IO</h3><p><del>在这点上，一个对于 <code>async</code>, <code>await</code> 来说更加正式的定义，并且由它们创建的协程函数是有序的。（At this point, a more formal definition of <code>async</code>, <code>await</code>, and the coroutine functions that they create are in order. ）</del>这部分内容比较繁琐，但是对于掌握 <code>async</code> /<code>await</code> 是有帮助的，因此，如果需要执行以下操作，请返回至此处：</p>
<ul>
<li>语法 <code>async def</code> 引入了<strong>原生协程（native coroutine）</strong>或一个<strong>异步生成器(asynchronous generator)</strong>。 <code>async with</code> 和 <code>async for</code> 这两个表达式也是有效的，稍后你就会看到它们。</li>
<li>关键字 <code>await</code> 将函数的控制权交还给事件循环。它暂停了当前协程的执行。如果Python在<code>g()</code>的范围内遇到<code>await f()</code>表达式，这就是<code>await</code>告诉事件循环，“暂停执行<code>g()</code>直到我等待的是<code>f()</code>返回的结果。同时，让其他东西运行。”</li>
</ul>
<p>在代码中，第二个要点大致如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Pause here and come back to g() when f() is ready</span></span><br><span class="line">    r = <span class="keyword">await</span> f()</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>

<p>关于何时、如何、能不能使用<code>async</code> /<code>await</code>的有着一套严格的规定。无论你仍在学习语法还是已经接触过使用 <code>async</code>/<code>await</code>，这些都可以很方便：</p>
<ul>
<li>你通过 <code>async def</code> 引入的函数是协程。它可以使用<code>await</code>，<code>return</code> 或 <code>yield</code> ，但是所有这些都是可选的。声明 <code>async def noop(): pass</code> 是有效的：<ul>
<li>使用 <code>await</code>或者<code>return</code>创建一个协程。要调用协程函数，必须 <code>await</code> 它以获得结果。</li>
<li>在 <code>async def</code> 块中使用<code>yield</code>是不太常见的（并且仅在 Python 中是最近才合法的）。这会创建一个<a href="https://www.python.org/dev/peps/pep-0525/" target="_blank" rel="noopener">异步生成器</a>，你可以使用 <code>async for</code> 进行迭代。暂时不要使用异步生成器，而将注意力集中在使用 <code>await</code> 和 <code>return</code> 的协程函数的语法上。</li>
<li>任何使用<code>async def</code>定义的函数不要使用<code>yield from</code>，它会引发一个<code>syntaxError</code>。</li>
</ul>
</li>
<li>就像在 <code>def</code> 函数之外使用 <code>yield</code> 会导致 <code>SyntaxError</code> ，在 <code>async def</code> 协程之外使用 <code>await</code> 也会引发 <code>SyntaxError</code>。你只能在协程体内使用<code>await</code>。</li>
</ul>
<p>这里有一些简短的例子去说明上面的规则：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    y = <span class="keyword">await</span> z(x)  <span class="comment"># OK - `await` and `return` allowed in coroutines</span></span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> x  <span class="comment"># OK - this is an async generator</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">m</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> gen(x)  <span class="comment"># No - SyntaxError</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m</span><span class="params">(x)</span>:</span></span><br><span class="line">    y = <span class="keyword">await</span> z(x)  <span class="comment"># Still no - SyntaxError (no `async def` here)</span></span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure>

<p>最后，当你使用<code>await f()</code>时，要求<code>f()</code>是<a href="https://docs.python.org/3/reference/datamodel.html#awaitable-objects" target="_blank" rel="noopener">awaitable</a>。好吧，那不是很有帮助，是吗？现在，只知道一个 awaitable 对象是：（1）另一个协程或（2）一个返回是迭代器并且定义了 <code>.__ await __()</code> 方法的对象。如果你正在编写一个程序，则出于大多数目的，你只需要担心第一种情况。</p>
<p>这给我们带来了另一个可能会遇到的技术：将函数标记为协程的一种较旧的方法是用<code>@asyncio.coroutine</code>装饰一个普通的<code>def</code>函数。结果是基于<strong>生成器的协程</strong>。自从 Python 3.5 中引入了 <code>async</code>/<code>await</code> 语法以来，这种构造已经过时了。</p>
<p>这两个协程在本质上是等效的（两者都是awaitable），但是第一个是<strong>基于生成器</strong>，而第二个是<strong>原生协程</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">py34_coro</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Generator-based coroutine, older syntax"""</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> stuff()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">py35_coro</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Native coroutine, modern syntax"""</span></span><br><span class="line">    <span class="keyword">await</span> stuff()</span><br></pre></td></tr></table></figure>

<p>如果只是你自己编写任何代码，则最好使用原生协程，以使其显式而不是隐式。在 Python 3.10 中，将<a href="https://docs.python.org/3/library/asyncio-task.html#generator-based-coroutines" target="_blank" rel="noopener">删除</a>基于生成器的协程。</p>
<p>在本教程的后半部分，我们将仅出于说明的目的触及基于生成器的协程。引入<code>async</code>/<code>await</code> 的原因是为了使协程成为 Python 的独立特性，可以很容易地将其与普通的生成器函数区分开，从而减少了歧义。</p>
<p>不要陷入基于生成器的协程，这些协程已经被<code>async</code>/<code>await</code> <a href="https://www.python.org/dev/peps/pep-0492/#rationale-and-goals" target="_blank" rel="noopener">所淘汰</a>。它们有自己的一小套规则（例如，<code>await</code> 不能在基于生成器的协程中使用），如果你坚持使用 <code>async</code> /<code>await</code> 语法，则它们在很大程度上是不相关的。</p>
<p>事不宜迟，让我们看更多的例子。</p>
<p>这是异步 IO 如何减少等待时间的一个示例：给定一个协程<code>makerandom()</code>，它不断产生范围为[0, 10]的随机整数，直到其中一个超过阈值为止，你希望多次调用这个协程不需要等待彼此相继完成。你可以在很大程度上遵循上述两个脚本的模式，并稍作更改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># rand.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># ANSI colors</span></span><br><span class="line">c = (</span><br><span class="line">    <span class="string">"\033[0m"</span>,   <span class="comment"># End of color</span></span><br><span class="line">    <span class="string">"\033[36m"</span>,  <span class="comment"># Cyan</span></span><br><span class="line">    <span class="string">"\033[91m"</span>,  <span class="comment"># Red</span></span><br><span class="line">    <span class="string">"\033[35m"</span>,  <span class="comment"># Magenta</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">makerandom</span><span class="params">(idx: int, threshold: int = <span class="number">6</span>)</span> -&gt; int:</span></span><br><span class="line">    print(c[idx + <span class="number">1</span>] + <span class="string">f"Initiated makerandom(<span class="subst">&#123;idx&#125;</span>)."</span>)</span><br><span class="line">    i = random.randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">while</span> i &lt;= threshold:</span><br><span class="line">        print(c[idx + <span class="number">1</span>] + <span class="string">f"makerandom(<span class="subst">&#123;idx&#125;</span>) == <span class="subst">&#123;i&#125;</span> too low; retrying."</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(idx + <span class="number">1</span>)</span><br><span class="line">        i = random.randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    print(c[idx + <span class="number">1</span>] + <span class="string">f"---&gt; Finished: makerandom(<span class="subst">&#123;idx&#125;</span>) == <span class="subst">&#123;i&#125;</span>"</span> + c[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    res = <span class="keyword">await</span> asyncio.gather(*(makerandom(i, <span class="number">10</span> - i - <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    random.seed(<span class="number">444</span>)</span><br><span class="line">    r1, r2, r3 = asyncio.run(main())</span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">f"r1: <span class="subst">&#123;r1&#125;</span>, r2: <span class="subst">&#123;r2&#125;</span>, r3: <span class="subst">&#123;r3&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>

<p>彩色输出的内容可以使您对如何执行此脚本有所了解：</p>
<img src="/2020/08/28/2020-08-28-Python%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5IO/asyncio-rand.dffdd83b4256.gif">

<p>rand.py execution</p>
<p>该程序使用一个主要的协程 <code>makerandom()</code>，并在3个不同的输入上同时运行它。大多数程序包含小型模块化协程和一个用于将每个较小的协程链接在一起的包装器函数。然后，通过将中央协程映射到一些可迭代对象或pool中，使用<code>main()</code>来收集任务（futures）。</p>
<p>在此微型示例中，pool 为<code>range(3)</code>。在稍后提供的完整示例中，有一组URL需要同时请求、解析和处理，而 <code>main()</code> 是封装了每个 URL 的整个例程。</p>
<p>虽然 “making random integers”（它其实是CPU相关的）可能不是使用 <code>asyncio</code> 最佳选择，但在示例中却存在<code>asyncio.sleep()</code>，旨在模仿<br>IO相关的过程，其中涉及不确定的等待时间。例如，<code>asyncio.sleep()</code>调用可能表示在消息应用程序中两个客户端之间发送和接收非随机整数。</p>
<h2 id="Async-IO-Design-Patterns"><a href="#Async-IO-Design-Patterns" class="headerlink" title="Async IO Design Patterns"></a>Async IO Design Patterns</h2><p>异步 IO 附带了自己的一组可能的脚本设计，本节将介绍它们。</p>
<h3 id="Chaining-Coroutines"><a href="#Chaining-Coroutines" class="headerlink" title="Chaining Coroutines"></a>Chaining Coroutines</h3><p>协程的一个关键特征是它们可以链接在一起。请记住，一个协程对象是 awaitable，因此另一个协程可以 <code>await</code> 它。这使您可以将程序分解为较小的，可管理的，可回收的协程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># chained.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">part1</span><span class="params">(n: int)</span> -&gt; str:</span></span><br><span class="line">    i = random.randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    print(<span class="string">f"part1(<span class="subst">&#123;n&#125;</span>) sleeping for <span class="subst">&#123;i&#125;</span> seconds."</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(i)</span><br><span class="line">    result = <span class="string">f"result<span class="subst">&#123;n&#125;</span>-1"</span></span><br><span class="line">    print(<span class="string">f"Returning part1(<span class="subst">&#123;n&#125;</span>) == <span class="subst">&#123;result&#125;</span>."</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">part2</span><span class="params">(n: int, arg: str)</span> -&gt; str:</span></span><br><span class="line">    i = random.randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    print(<span class="string">f"part2<span class="subst">&#123;n, arg&#125;</span> sleeping for <span class="subst">&#123;i&#125;</span> seconds."</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(i)</span><br><span class="line">    result = <span class="string">f"result<span class="subst">&#123;n&#125;</span>-2 derived from <span class="subst">&#123;arg&#125;</span>"</span></span><br><span class="line">    print(<span class="string">f"Returning part2<span class="subst">&#123;n, arg&#125;</span> == <span class="subst">&#123;result&#125;</span>."</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    start = time.perf_counter()</span><br><span class="line">    p1 = <span class="keyword">await</span> part1(n)</span><br><span class="line">    p2 = <span class="keyword">await</span> part2(n, p1)</span><br><span class="line">    end = time.perf_counter() - start</span><br><span class="line">    print(<span class="string">f"--&gt;Chained result<span class="subst">&#123;n&#125;</span> =&gt; <span class="subst">&#123;p2&#125;</span> (took <span class="subst">&#123;end:<span class="number">0.2</span>f&#125;</span> seconds)."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*(chain(n) <span class="keyword">for</span> n <span class="keyword">in</span> args))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    random.seed(<span class="number">444</span>)</span><br><span class="line">    args = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">if</span> len(sys.argv) == <span class="number">1</span> <span class="keyword">else</span> map(int, sys.argv[<span class="number">1</span>:])</span><br><span class="line">    start = time.perf_counter()</span><br><span class="line">    asyncio.run(main(*args))</span><br><span class="line">    end = time.perf_counter() - start</span><br><span class="line">    print(<span class="string">f"Program finished in <span class="subst">&#123;end:<span class="number">0.2</span>f&#125;</span> seconds."</span>)</span><br></pre></td></tr></table></figure>

<p>注意输出，<code>part1()</code> 睡眠一段可变的时间，<code>part2()</code> 在结果可用时开始处理结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ python3 chained.py <span class="number">9</span> <span class="number">6</span> <span class="number">3</span></span><br><span class="line">part1(<span class="number">9</span>) sleeping <span class="keyword">for</span> <span class="number">4</span> seconds.</span><br><span class="line">part1(<span class="number">6</span>) sleeping <span class="keyword">for</span> <span class="number">4</span> seconds.</span><br><span class="line">part1(<span class="number">3</span>) sleeping <span class="keyword">for</span> <span class="number">0</span> seconds.</span><br><span class="line">Returning part1(<span class="number">3</span>) == result3<span class="number">-1.</span></span><br><span class="line">part2(<span class="number">3</span>, <span class="string">'result3-1'</span>) sleeping <span class="keyword">for</span> <span class="number">4</span> seconds.</span><br><span class="line">Returning part1(<span class="number">9</span>) == result9<span class="number">-1.</span></span><br><span class="line">part2(<span class="number">9</span>, <span class="string">'result9-1'</span>) sleeping <span class="keyword">for</span> <span class="number">7</span> seconds.</span><br><span class="line">Returning part1(<span class="number">6</span>) == result6<span class="number">-1.</span></span><br><span class="line">part2(<span class="number">6</span>, <span class="string">'result6-1'</span>) sleeping <span class="keyword">for</span> <span class="number">4</span> seconds.</span><br><span class="line">Returning part2(<span class="number">3</span>, <span class="string">'result3-1'</span>) == result3<span class="number">-2</span> derived <span class="keyword">from</span> result3<span class="number">-1.</span></span><br><span class="line">--&gt;Chained result3 =&gt; result3-2 derived from result3-1 (took 4.00 seconds).</span><br><span class="line">Returning part2(<span class="number">6</span>, <span class="string">'result6-1'</span>) == result6<span class="number">-2</span> derived <span class="keyword">from</span> result6<span class="number">-1.</span></span><br><span class="line">--&gt;Chained result6 =&gt; result6-2 derived from result6-1 (took 8.01 seconds).</span><br><span class="line">Returning part2(<span class="number">9</span>, <span class="string">'result9-1'</span>) == result9<span class="number">-2</span> derived <span class="keyword">from</span> result9<span class="number">-1.</span></span><br><span class="line">--&gt;Chained result9 =&gt; result9-2 derived from result9-1 (took 11.01 seconds).</span><br><span class="line">Program finished <span class="keyword">in</span> <span class="number">11.01</span> seconds.</span><br></pre></td></tr></table></figure>

<p>在这种设置中，<code>main()</code> 的运行时间将等于它收集在一起并调度的任务中最大的运行时间。</p>
<h3 id="Using-a-Queue"><a href="#Using-a-Queue" class="headerlink" title="Using a Queue"></a>Using a Queue</h3><p><code>asyncio</code>库中提供了<a href="https://docs.python.org/3/library/asyncio-queue.html" target="_blank" rel="noopener">queue classes</a>，它们被设计为类似于<a href="https://docs.python.org/3/library/queue.html#module-queue" target="_blank" rel="noopener"><code>queue</code></a>模块。到目前为止，在我们的示例中，我们实际上并不需要队列结构。在<code>chained.py</code> 中，每个任务（future）都由一组协程组成，这些协程明确地相互 <code>await</code> ，并通过每个链上都有一个输入。</p>
<p>还有一个也可以与异步IO一起使用的结构：许多彼此不相关的生产者将项目添加到队列中。每个生产者可以在交错、随机或未通知的时间内将多个项目添加到队列中。一群消费者在它们出现时将它们从队列中取出，而不必等待任何其他信号。</p>
<p>在这种设计中，没有任何个消费者链接到生产者。消费者不知道生产者的数量，甚至不知道将要添加到队列中的项目的累计数量。</p>
<p>每个生产者或消费者花费可变的时间分别从队列中放入和取出项目。队列用作可以与生产者和消费者进行通信的中间件，而无需他们彼此直接交谈。</p>
<p><strong>注意</strong>：由于 <code>queue.Queue()</code> 的线程安全性，队列通常在线程程序中使用，但在异步IO方面，您不必担心线程安全。</p>
<p>队列的一个用例（如此处的情况）是充当生产者和消费者的发送者，而这些生产者和消费者原本不是直接链接或彼此关联的。</p>
<p>该程序的同步版本看起来非常令人沮丧：一组阻塞的生产者将项目串行添加到队列中，一次添加一个生产者。只有在所有生产者都完成之后，队列才能由一个消费者逐项处理。此设计存在大量延迟。项目可能闲置在队列中，而不是立即拿起并处理。</p>
<p>下面是一个异步版本 <code>asyncq.py</code>。此工作流程中具有挑战性的部分是，需要向消费者发出生产已完成的信号。否则，<code>await q.get()</code>将无限期挂起，因为队列已被完全处理，但是消费者不会知道生产已经完成。</p>
<p>下面是完整的脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># asyncq.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> itertools <span class="keyword">as</span> it</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">makeitem</span><span class="params">(size: int = <span class="number">5</span>)</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">return</span> os.urandom(size).hex()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">randsleep</span><span class="params">(a: int = <span class="number">1</span>, b: int = <span class="number">5</span>, caller=None)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    i = random.randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> caller:</span><br><span class="line">        print(<span class="string">f"<span class="subst">&#123;caller&#125;</span> sleeping for <span class="subst">&#123;i&#125;</span> seconds."</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(name: int, q: asyncio.Queue)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    n = random.randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> it.repeat(<span class="literal">None</span>, n):  <span class="comment"># Synchronous loop for each single producer</span></span><br><span class="line">        <span class="keyword">await</span> randsleep(caller=<span class="string">f"Producer <span class="subst">&#123;name&#125;</span>"</span>)</span><br><span class="line">        i = <span class="keyword">await</span> makeitem()</span><br><span class="line">        t = time.perf_counter()</span><br><span class="line">        <span class="keyword">await</span> q.put((i, t))</span><br><span class="line">        print(<span class="string">f"Producer <span class="subst">&#123;name&#125;</span> added &lt;<span class="subst">&#123;i&#125;</span>&gt; to queue."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">(name: int, q: asyncio.Queue)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">await</span> randsleep(caller=<span class="string">f"Consumer <span class="subst">&#123;name&#125;</span>"</span>)</span><br><span class="line">        i, t = <span class="keyword">await</span> q.get()</span><br><span class="line">        now = time.perf_counter()</span><br><span class="line">        print(<span class="string">f"Consumer <span class="subst">&#123;name&#125;</span> got element &lt;<span class="subst">&#123;i&#125;</span>&gt;"</span></span><br><span class="line">              <span class="string">f" in <span class="subst">&#123;now-t:<span class="number">0.5</span>f&#125;</span> seconds."</span>)</span><br><span class="line">        q.task_done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(nprod: int, ncon: int)</span>:</span></span><br><span class="line">    q = asyncio.Queue()</span><br><span class="line">    producers = [asyncio.create_task(produce(n, q)) <span class="keyword">for</span> n <span class="keyword">in</span> range(nprod)]</span><br><span class="line">    consumers = [asyncio.create_task(consume(n, q)) <span class="keyword">for</span> n <span class="keyword">in</span> range(ncon)]</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*producers)</span><br><span class="line">    <span class="keyword">await</span> q.join()  <span class="comment"># Implicitly awaits consumers, too</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> consumers:</span><br><span class="line">        c.cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> argparse</span><br><span class="line">    random.seed(<span class="number">444</span>)</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">"-p"</span>, <span class="string">"--nprod"</span>, type=int, default=<span class="number">5</span>)</span><br><span class="line">    parser.add_argument(<span class="string">"-c"</span>, <span class="string">"--ncon"</span>, type=int, default=<span class="number">10</span>)</span><br><span class="line">    ns = parser.parse_args()</span><br><span class="line">    start = time.perf_counter()</span><br><span class="line">    asyncio.run(main(**ns.__dict__))</span><br><span class="line">    elapsed = time.perf_counter() - start</span><br><span class="line">    print(<span class="string">f"Program completed in <span class="subst">&#123;elapsed:<span class="number">0.5</span>f&#125;</span> seconds."</span>)</span><br></pre></td></tr></table></figure>

<p>前几个协程是辅助函数，它们返回一个随机字符串，一个小数秒性能计数器和一个随机整数。生产者将1到5个项目放入队列中。每个项目都是 <code>(i，t)</code> 的元组，其中<code>i</code>是随机字符串，而 <code>t</code> 是生产者尝试将元组放入队列的时间。</p>
<p>消费者将商品取出时，它仅使用商品放入的时间戳来计算商品在队列中的经过时间。</p>
<p>请记住，<code>asyncio.sleep()</code>用于模仿其他更复杂的协程，如果这是常规的阻塞函数，则会消耗时间并阻止所有其他执行。</p>
<p>下面是由两个生产者和五个消费者进行的测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ python3 asyncq.py -p <span class="number">2</span> -c <span class="number">5</span></span><br><span class="line">Producer <span class="number">0</span> sleeping <span class="keyword">for</span> <span class="number">3</span> seconds.</span><br><span class="line">Producer <span class="number">1</span> sleeping <span class="keyword">for</span> <span class="number">3</span> seconds.</span><br><span class="line">Consumer <span class="number">0</span> sleeping <span class="keyword">for</span> <span class="number">4</span> seconds.</span><br><span class="line">Consumer <span class="number">1</span> sleeping <span class="keyword">for</span> <span class="number">3</span> seconds.</span><br><span class="line">Consumer <span class="number">2</span> sleeping <span class="keyword">for</span> <span class="number">3</span> seconds.</span><br><span class="line">Consumer <span class="number">3</span> sleeping <span class="keyword">for</span> <span class="number">5</span> seconds.</span><br><span class="line">Consumer <span class="number">4</span> sleeping <span class="keyword">for</span> <span class="number">4</span> seconds.</span><br><span class="line">Producer <span class="number">0</span> added &lt;<span class="number">377</span>b1e8f82&gt; to queue.</span><br><span class="line">Producer <span class="number">0</span> sleeping <span class="keyword">for</span> <span class="number">5</span> seconds.</span><br><span class="line">Producer <span class="number">1</span> added &lt;<span class="number">413</span>b8802f8&gt; to queue.</span><br><span class="line">Consumer <span class="number">1</span> got element &lt;<span class="number">377</span>b1e8f82&gt; <span class="keyword">in</span> <span class="number">0.00013</span> seconds.</span><br><span class="line">Consumer <span class="number">1</span> sleeping <span class="keyword">for</span> <span class="number">3</span> seconds.</span><br><span class="line">Consumer <span class="number">2</span> got element &lt;<span class="number">413</span>b8802f8&gt; <span class="keyword">in</span> <span class="number">0.00009</span> seconds.</span><br><span class="line">Consumer <span class="number">2</span> sleeping <span class="keyword">for</span> <span class="number">4</span> seconds.</span><br><span class="line">Producer <span class="number">0</span> added &lt;<span class="number">06</span>c055b3ab&gt; to queue.</span><br><span class="line">Producer <span class="number">0</span> sleeping <span class="keyword">for</span> <span class="number">1</span> seconds.</span><br><span class="line">Consumer <span class="number">0</span> got element &lt;<span class="number">06</span>c055b3ab&gt; <span class="keyword">in</span> <span class="number">0.00021</span> seconds.</span><br><span class="line">Consumer <span class="number">0</span> sleeping <span class="keyword">for</span> <span class="number">4</span> seconds.</span><br><span class="line">Producer <span class="number">0</span> added &lt;<span class="number">17</span>a8613276&gt; to queue.</span><br><span class="line">Consumer <span class="number">4</span> got element &lt;<span class="number">17</span>a8613276&gt; <span class="keyword">in</span> <span class="number">0.00022</span> seconds.</span><br><span class="line">Consumer <span class="number">4</span> sleeping <span class="keyword">for</span> <span class="number">5</span> seconds.</span><br><span class="line">Program completed <span class="keyword">in</span> <span class="number">9.00954</span> seconds.</span><br></pre></td></tr></table></figure>

<p>在这种情况下，项目将在几分之一秒内完成处理。造成延迟的原因可能有两个：</p>
<ul>
<li>标准的，基本无法避免的开销</li>
<li>队列中出现某个项目时所有消费者都处在sleep状态</li>
</ul>
<p>关于第二个原因，幸运的是，扩展到成百上千的消费者是完全正常的。你使用 <code>python3 asyncq.py -p 5 -c 100</code> 是没有问题。这里的重点是，从理论上来说，您可以在不同的系统上使用不同的用户来控制生产者和消费者的管理，而队列则作为中心进行吞吐。</p>
<p>到目前为止，您已经陷入困境，并看到了三个相关的例子，分别是 <code>asyncio</code> 调用用 <code>async</code> 和 <code>await</code> 定义的协程。如果您不完全了解或只是想更深入地了解现代协程在Python中的使用机理，那么您将从下一节开始。</p>
<h2 id="Async-IO’s-Roots-in-Generators"><a href="#Async-IO’s-Roots-in-Generators" class="headerlink" title="Async IO’s Roots in Generators"></a>Async IO’s Roots in Generators</h2><p>之前，您看到了一个基于生成器的老式协程的示例，该协程已被更明确的原生协程所淘汰。该示例值得稍作调整并用来展示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">py34_coro</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Generator-based coroutine"""</span></span><br><span class="line">    <span class="comment"># No need to build these yourself, but be aware of what they are</span></span><br><span class="line">    s = <span class="keyword">yield</span> <span class="keyword">from</span> stuff()</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">py35_coro</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Native coroutine, modern syntax"""</span></span><br><span class="line">    s = <span class="keyword">await</span> stuff()</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">stuff</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x30</span></span><br></pre></td></tr></table></figure>

<p>作为实验，如果您单独调用 <code>py34_coro()</code> 或 <code>py35_coro()</code> ，而没有 <code>await</code> ，或者没有任何对 <code>asyncio.run()</code> 或其他 <code>asyncio</code> 函数的调用，会发生什么情况？ 孤立地调用协程将返回协程对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>py35_coro()</span><br><span class="line">&lt;coroutine object py35_coro at <span class="number">0x10126dcc8</span>&gt;</span><br></pre></td></tr></table></figure>

<p>这表面上看起来没有那么有趣。单独调用协程的结果是一个 awaitable <strong>协程对象</strong>。</p>
<p>Python还有其它的什么类似的特征吗？</p>
<p>希望您将<strong>生成器</strong>视为该问题的答案，因为协程是内部强化的生成器。在这方面，行为是相似的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x30</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = gen()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g  <span class="comment"># Nothing much happens - need to iterate with `.__next__()`</span></span><br><span class="line">&lt;generator object gen at <span class="number">0x1012705e8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line">(<span class="number">16</span>, <span class="number">32</span>, <span class="number">48</span>)</span><br></pre></td></tr></table></figure>

<p>碰巧的是，生成器函数是异步IO的基础（无论您是使用<code>async def</code>声明协程，还是使用旧的<code>@asyncio.coroutine</code>装饰器声明）。从技术上讲，<code>await</code>与 <code>yield</code>相比更类似于<code>yield from</code>。（但请记住，<code>yield from x()</code> 仅仅是 <code>for i in x(): yield i</code> 的语法糖。）</p>
<p>与异步IO有关的生成器的一项关键功能是可以有效地随意停止和重启。例如，您可以 <code>break</code> 迭代生成器对象，然后在剩余的值上恢复迭代。当生成器函数达到 <code>yield</code> 时，它会<code>yield</code>该值，但随后会处于空闲状态，直到被告知要生成其后续值。</p>
<p>下面是一个关于这方面的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> cycle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">endless</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""Yields 9, 8, 7, 6, 9, 8, 7, 6, ... forever"""</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="keyword">from</span> cycle((<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = endless()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>total = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> e:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> total &lt; <span class="number">30</span>:</span><br><span class="line"><span class="meta">... </span>        print(i, end=<span class="string">" "</span>)</span><br><span class="line"><span class="meta">... </span>        total += i</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        print()</span><br><span class="line"><span class="meta">... </span>        <span class="comment"># Pause execution. We can resume later.</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">break</span></span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">9</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Resume</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(e), next(e), next(e)</span><br><span class="line">(<span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p>关键字 <code>await</code> 的行为类似，它标出了协程自动挂起并让其他协程工作的断点。在这种情况下，<code>break</code>是指已暂时放弃控制权但尚未完全退出或结束的协程。请记住，<code>yield</code>（以及扩展为 <code>yield from</code> 和<code>await</code> ）是生成器执行中的一个断点。</p>
<p>这是函数和生成器之间的根本区别。功能是全有还是全无。一旦启动，它将不会停止，直到它遇到一个<code>return</code>，然后将该值返回给调用者（调用它的函数）。另一方面，生成器每次遇到<code>yield</code>时都会暂停，并且不再前进。它不仅可以将此值推送到调用堆栈，而且还可以通过在其上调用 <code>next()</code> 来保留其局部变量。</p>
<p>生成器的第二个鲜为人知的功能也很重要。您也可以通过其 <code>.send()</code> 方法将值发送到生成器中。这允许生成器（和协程）在不阻塞的情况下相互调用（<code>await</code>）。我不会再赘述此功能了，因为它主要对幕后协程的实现很重要，但是您根本不需要自己直接使用它。</p>
<p>如果您有兴趣探索更多内容，可以从<a href="https://www.python.org/dev/peps/pep-0342/" target="_blank" rel="noopener">PEP 342</a>开始，在此正式引入了协程。布雷特·坎农（Brett Cannon）的<a href="https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/" target="_blank" rel="noopener">How the Heck Does Async-Await Work in Python</a>也是一个很好的选择阅读，<a href="https://pymotw.com/3/asyncio/coroutines.html" target="_blank" rel="noopener">PYMOTW writeup on <code>asyncio</code></a>一样。最后，还有大卫·比兹利（David Beazley）的<a href="http://www.dabeaz.com/coroutines/" target="_blank" rel="noopener">Curious Course on Coroutines and Concurrency</a>，它深入探讨了协程的运行机制。</p>
<p>让我们尝试将以上所有文章压缩成几句话：<strong>这些协程实际上是通过一种特殊的非常规机制运行的。他们的结果是异常对象的属性，该异常对象在调用他们的 <code>.send()</code> 方法时被抛出。</strong>所有的这些还有更多的细节，但这可能无法帮助您在实践中使用这部分。</p>
<p>为了将事情联系在一起，以下是协程作为生成器的主题的一些关键点：</p>
<ul>
<li>协程是<a href="https://www.python.org/dev/peps/pep-0492/#differences-from-generators" target="_blank" rel="noopener">专用生成器</a>，利用生成器方法的独特性。 </li>
<li>旧的基于生成器的协程使用<code>yield from</code>来等待协程结果。原生协程中的现代Python语法仅将<code>yield from</code>替换为<code>await</code>，作为等待协程结果的手段。<br>  <code>await</code> 类似于 <code>yield from</code>，并且通常有助于将其视为 <code>yield from</code>。 </li>
<li>使用 <code>await</code> 是标记断点的信号。它允许协程暂时中止执行，并允许程序稍后返回。</li>
</ul>
<h3 id="Other-Features-async-for-and-Async-Generators-Comprehensions"><a href="#Other-Features-async-for-and-Async-Generators-Comprehensions" class="headerlink" title="Other Features: async for and Async Generators + Comprehensions"></a>Other Features: <code>async for</code> and Async Generators + Comprehensions</h3><p>除了普通的<code>async</code>/<code>await</code>，Python 还使<code>async for</code>可以在<strong>异步迭代器</strong>上进行迭代。异步迭代器的目的是使它能够在迭代时在每个阶段调用异步代码。</p>
<p>这个概念的自然扩展是<strong>异步生成器</strong>。回想一下，您可以在本地协程中使用<code>await</code>，<code>return</code>或<code>yield</code>。在Python 3.6中（通过PEP 525）可以在协程中使用<code>yield</code>，该引入了异步生成器，目的是允许在同一协程函数体中使用<code>await</code>和<code>yield</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">mygen</span><span class="params">(u: int = <span class="number">10</span>)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""Yield powers of 2."""</span></span><br><span class="line"><span class="meta">... </span>    i = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> i &lt; u:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> <span class="number">2</span> ** i</span><br><span class="line"><span class="meta">... </span>        i += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>

<p>最后，Python 通过 <code>async for</code>实现了异步表达式。和同步的表达式类似，这是一个巨大的语法糖：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="comment"># This does *not* introduce concurrent execution</span></span><br><span class="line"><span class="meta">... </span>    <span class="comment"># It is meant to show syntax only</span></span><br><span class="line"><span class="meta">... </span>    g = [i <span class="keyword">async</span> <span class="keyword">for</span> i <span class="keyword">in</span> mygen()]</span><br><span class="line"><span class="meta">... </span>    f = [j <span class="keyword">async</span> <span class="keyword">for</span> j <span class="keyword">in</span> mygen() <span class="keyword">if</span> <span class="keyword">not</span> (j // <span class="number">3</span> % <span class="number">5</span>)]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> g, f</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g, f = asyncio.run(main())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">256</span>, <span class="number">512</span>]</span><br></pre></td></tr></table></figure>

<p>这是一个至关重要的区别：<strong>异步生成器和表达式都不会使迭代并发</strong>。他们所做的只是提供同步对象的外观，但具有使相关循环放弃对事件循环的控制权以便其他协程运行的能力。</p>
<p>换句话说，异步迭代器和异步生成器并未设计为在序列或迭代器上同时映射某些功能。它们只是为了让封闭的协程允许其他任务轮流使用。仅在以下情况下才需要使用 <code>async for</code> 和 <code>async with</code> 语句：使用普通的 <code>for</code> 或<code>with</code>会<code>break</code>协程中<code>await</code>的性质。这个异步和并发之间的区别就是要把握的关键。</p>
<h3 id="The-Event-Loop-and-asyncio-run"><a href="#The-Event-Loop-and-asyncio-run" class="headerlink" title="The Event Loop and asyncio.run()"></a>The Event Loop and <code>asyncio.run()</code></h3><p><strong>您可以将事件循环想像成 <code>while True</code> 循环，该循环监视协程，获取有关空闲状态的反馈，并四处寻找可以同时执行的事情。当协程正在等待的东西可用时，它能够唤醒一个空闲的协程。</strong></p>
<p>到目前为止，事件循环的整个管理已由一个函数调用隐式处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asyncio.run(main())  <span class="comment"># Python 3.7+</span></span><br></pre></td></tr></table></figure>

<p>负责获取事件循环，运行任务，直到将其标记为已完成，然后关闭事件循环。</p>
<p>使用<code>get_event_loop()</code>，可以更轻松地管理<code>asyncio</code>事件循环。典型的模式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop &#x3D; asyncio.get_event_loop()</span><br><span class="line">try:</span><br><span class="line">    loop.run_until_complete(main())</span><br><span class="line">finally:</span><br><span class="line">    loop.close()</span><br></pre></td></tr></table></figure>

<p>You’ll probably see <code>loop.get_event_loop()</code> floating around in older examples, but unless you have a specific need to fine-tune control over the event loop management, <code>asyncio.run()</code> should be sufficient for most programs.</p>
<p>在较早的示例中，您可能会看到<code>loop.get_event_loop()</code>随处可见，但是除非您有特定的需求需要微调对事件循环管理的控制，否则对于大多数程序而言，<code>asyncio.run()</code>就足够了。</p>
<p>如果确实需要与 Python 程序中的事件循环进行交互，则 <code>loop</code> 是一个老式的 Python 对象，它通过 <code>loop.is_running()</code>和<code>loop.is_closed()</code>支持自省。如果您需要获得更精细的控制，就可以操作这个对此昂，例如<a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio-example-lowlevel-helloworld" target="_blank" rel="noopener">scheduling a callback</a>，方法是将循环作为参数进行传递。</p>
<p>更关键的是要对事件循环的机制有一些了解。以下是有关事件循环的一些要点。</p>
<p><strong>#1:</strong> 协程在绑定到事件循环之前并不会做很多事情。</p>
<p>您之前在有关生成器的说明中已经看到了这一点，但值得重申。如果您有一个等待的主协程，则简单地单独调用它几乎没有效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Hello ..."</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"World!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>routine = main()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>routine</span><br><span class="line">&lt;coroutine object main at <span class="number">0x1027a6150</span>&gt;</span><br></pre></td></tr></table></figure>

<p>Remember to use <code>asyncio.run()</code> to actually force execution by scheduling the <code>main()</code> coroutine (future object) for execution on the event loop:</p>
<p>记住使用 <code>asyncio.run()</code>通过调度<code>main()</code>协程（future object）在事件循环上执行来实际强制执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>asyncio.run(routine)</span><br><span class="line">Hello ...</span><br><span class="line">World!</span><br></pre></td></tr></table></figure>

<p>（其他协程可以用<code>await</code>执行。通常将<code>main()</code>包装在<code>asyncio.run()</code>中，然后从中调用与<code>await</code>链接的协程。）</p>
<p><strong>#2:</strong> 默认情况下，异步IO事件循环在单个线程和单个CPU内核上运行。通常，在一个CPU内核中运行一个单线程事件循环绰绰有余。还可以跨多个内核运行事件循环。</p>
<p><strong>#3.</strong> 事件循环是可插入的。也就是说，如果您确实需要，可以编写自己的事件循环实现，并使它运行相同的任务。这在<a href="https://github.com/MagicStack/uvloop" target="_blank" rel="noopener"><code>uvloop</code></a>软件包中得到了很好的演示，该软件包是Cython中事件循环的实现。</p>
<p>这就是术语“可插入事件循环”的含义：您可以使用事件循环的任何可行实现，而与协程本身的结构无关。<code>asyncio</code>包本身附带<a href="https://docs.python.org/3/library/asyncio-eventloop.html#event-loop-implementations" target="_blank" rel="noopener">两种不同的事件循环实现</a>，默认设置基于<a href="https://docs.python.org/3/library/selectors.html#module-selectors" target="_blank" rel="noopener"><code>selectors</code></a>模块。（第二种实现仅适用于Windows。）</p>
<h2 id="A-Full-Program-Asynchronous-Requests"><a href="#A-Full-Program-Asynchronous-Requests" class="headerlink" title="A Full Program: Asynchronous Requests"></a>A Full Program: Asynchronous Requests</h2><p>到目前为止，您已经学习了很多，现在该是有趣而轻松的部分了。在本部分中，您将使用<code>aiohttp</code>（一个非常快的异步HTTP客户端/服务器框架）构建一个抓取网址的网址收集器<code>areq.py</code>。 这样的工具可用于映射站点集群之间的连接，链接形成一个<a href="https://en.wikipedia.org/wiki/Directed_graph" target="_blank" rel="noopener">有向图</a>。<br><strong>注意</strong>：您可能想知道为什么Python的<code>requests</code>包与异步IO不兼容。 <code>requests</code>建立在<code>urllib3</code>之上，而<code>urllib3</code>则使用 Python 的<code>http</code>和<code>socket</code>模块。</p>
<p>默认情况下，套接字操作处于阻塞状态。这意味着Python不会喜欢 <code>await requests.get(url)</code>，因为<code>.get()</code>不是 awaitable 的。相比之下，<code>aiohttp</code>中的几乎所有内容都是可以awaitable的协程，例如<a href="https://github.com/aio-libs/aiohttp/blob/508adbb656da2e9ae660da5e98e1e5fa6669a3f4/aiohttp/client.py#L225" target="_blank" rel="noopener"><code>session.request()</code></a>和<a href="https://github.com/aio-libs/aiohttp/blob/da75122f6089a250128d2736f2bd88d10e97ca17/aiohttp/client_reqrep.py#L913" target="_blank" rel="noopener"><code>response.text()</code></a>。否则，它是一个很棒的软件包，但是您在异步代码中使用<code>requests</code>没有任何用处。</p>
<p>高级程序结构如下所示：</p>
<ol>
<li>从本地文件<code>urls.txt</code>中读取URL序列。</li>
<li>发送对URL的GET请求并解码结果内容。如果失败，请在此处停止输入URL。</li>
<li>在响应的HTML中的<code>href</code>标记内搜索URL。</li>
<li>将结果写入<code>foundurls.txt</code>。</li>
<li>尽可能异步同时执行上述所有操作。（将<code>aiohttp</code>用于请求，将<code>aiofiles</code>用于文件附件。这是两个非常适合异步IO模型的IO主要示例。）</li>
</ol>
<p>以下是<code>urls.txt</code>的内容。它并不庞大，并且包含流量最高的网站：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat urls.txt</span></span><br><span class="line">https://regex101.com/</span><br><span class="line">https://docs.python.org/3/this-url-will-404.html</span><br><span class="line">https://www.nytimes.com/guides/</span><br><span class="line">https://www.mediamatters.org/</span><br><span class="line">https://1.1.1.1/</span><br><span class="line">https://www.politico.com/tipsheets/morning-money</span><br><span class="line">https://www.bloomberg.com/markets/economics</span><br><span class="line">https://www.ietf.org/rfc/rfc2616.txt</span><br></pre></td></tr></table></figure>

<p>列表中的第二个URL应该返回404响应，您需要对其进行适当处理。如果您正在运行此程序的扩展版本，则可能需要处理比这更棘手的问题，例如服务器断开连接和无止尽的重定向。</p>
<p>请求本身应使用单个 session 发出，以充分利用会话的内部连接池。</p>
<p>让我们看一下完整的程序。我们将逐步介绍以下内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># areq.py</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""Asynchronously get links embedded in multiple pages' HMTL."""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> IO</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiofiles</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    format=<span class="string">"%(asctime)s %(levelname)s:%(name)s: %(message)s"</span>,</span><br><span class="line">    level=logging.DEBUG,</span><br><span class="line">    datefmt=<span class="string">"%H:%M:%S"</span>,</span><br><span class="line">    stream=sys.stderr,</span><br><span class="line">)</span><br><span class="line">logger = logging.getLogger(<span class="string">"areq"</span>)</span><br><span class="line">logging.getLogger(<span class="string">"chardet.charsetprober"</span>).disabled = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">HREF_RE = re.compile(<span class="string">r'href="(.*?)"'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_html</span><span class="params">(url: str, session: ClientSession, **kwargs)</span> -&gt; str:</span></span><br><span class="line">    <span class="string">"""GET request wrapper to fetch page HTML.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    kwargs are passed to `session.request()`.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    resp = <span class="keyword">await</span> session.request(method=<span class="string">"GET"</span>, url=url, **kwargs)</span><br><span class="line">    resp.raise_for_status()</span><br><span class="line">    logger.info(<span class="string">"Got response [%s] for URL: %s"</span>, resp.status, url)</span><br><span class="line">    html = <span class="keyword">await</span> resp.text()</span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(url: str, session: ClientSession, **kwargs)</span> -&gt; set:</span></span><br><span class="line">    <span class="string">"""Find HREFs in the HTML of `url`."""</span></span><br><span class="line">    found = set()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        html = <span class="keyword">await</span> fetch_html(url=url, session=session, **kwargs)</span><br><span class="line">    <span class="keyword">except</span> (</span><br><span class="line">        aiohttp.ClientError,</span><br><span class="line">        aiohttp.http_exceptions.HttpProcessingError,</span><br><span class="line">    ) <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(</span><br><span class="line">            <span class="string">"aiohttp exception for %s [%s]: %s"</span>,</span><br><span class="line">            url,</span><br><span class="line">            getattr(e, <span class="string">"status"</span>, <span class="literal">None</span>),</span><br><span class="line">            getattr(e, <span class="string">"message"</span>, <span class="literal">None</span>),</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.exception(</span><br><span class="line">            <span class="string">"Non-aiohttp exception occured:  %s"</span>, getattr(e, <span class="string">"__dict__"</span>, &#123;&#125;)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> link <span class="keyword">in</span> HREF_RE.findall(html):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                abslink = urllib.parse.urljoin(url, link)</span><br><span class="line">            <span class="keyword">except</span> (urllib.error.URLError, ValueError):</span><br><span class="line">                logger.exception(<span class="string">"Error parsing URL: %s"</span>, link)</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                found.add(abslink)</span><br><span class="line">        logger.info(<span class="string">"Found %d links for %s"</span>, len(found), url)</span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">write_one</span><span class="params">(file: IO, url: str, **kwargs)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="string">"""Write the found HREFs from `url` to `file`."""</span></span><br><span class="line">    res = <span class="keyword">await</span> parse(url=url, **kwargs)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.open(file, <span class="string">"a"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> res:</span><br><span class="line">            <span class="keyword">await</span> f.write(<span class="string">f"<span class="subst">&#123;url&#125;</span>\t<span class="subst">&#123;p&#125;</span>\n"</span>)</span><br><span class="line">        logger.info(<span class="string">"Wrote results for source URL: %s"</span>, url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">bulk_crawl_and_write</span><span class="params">(file: IO, urls: set, **kwargs)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="string">"""Crawl &amp; write concurrently to `file` for multiple `urls`."""</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        tasks = []</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            tasks.append(</span><br><span class="line">                write_one(file=file, url=url, session=session, **kwargs)</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> pathlib</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> sys.version_info &gt;= (<span class="number">3</span>, <span class="number">7</span>), <span class="string">"Script requires Python 3.7+."</span></span><br><span class="line">    here = pathlib.Path(__file__).parent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(here.joinpath(<span class="string">"urls.txt"</span>)) <span class="keyword">as</span> infile:</span><br><span class="line">        urls = set(map(str.strip, infile))</span><br><span class="line"></span><br><span class="line">    outpath = here.joinpath(<span class="string">"foundurls.txt"</span>)</span><br><span class="line">    <span class="keyword">with</span> open(outpath, <span class="string">"w"</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">        outfile.write(<span class="string">"source_url\tparsed_url\n"</span>)</span><br><span class="line"></span><br><span class="line">    asyncio.run(bulk_crawl_and_write(file=outpath, urls=urls))</span><br></pre></td></tr></table></figure>

<p>该脚本比我们最初的玩具程序要长，所以让我们对其进行分解。</p>
<p>常量<code>HREF_RE</code>是一个<a href="https://realpython.com/regex-python/" target="_blank" rel="noopener">正则表达式</a>，用于提取我们最终在HTML中寻找的<code>href</code>标签：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>HREF_RE.search(<span class="string">'Go to &lt;a href="https://realpython.com/"&gt;Real Python&lt;/a&gt;'</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">15</span>, <span class="number">45</span>), match=<span class="string">'href="https://realpython.com/"'</span>&gt;</span><br></pre></td></tr></table></figure>

<p>协程<code>fetch_html()</code>是GET请求的包装，用于发出请求并解码生成的页面HTML。它发出请求，等待响应，并在非200状态下立即引发：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resp = <span class="keyword">await</span> session.request(method=<span class="string">"GET"</span>, url=url, **kwargs)</span><br><span class="line">resp.raise_for_status()</span><br></pre></td></tr></table></figure>

<p>如果状态正常，<code>fetch_html()</code>返回页面HTML(<code>str</code>)。值得注意的是，此函数没有完成异常处理。逻辑是将该异常传播给调用者，并在那里进行处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html = <span class="keyword">await</span> resp.text()</span><br></pre></td></tr></table></figure>

<p>我们<code>await</code> <code>session.request()</code>和<code>resp.text()</code>是因为它们是可以 awaitable 的协程。否则请求/响应周期将是应用程序的耗时的部分，但是对于异步IO来说，<code>fetch_html()</code>使事件循环可用于其他易于获取的作业上，例如解析和写入已获取的URL。</p>
<p>协程链中的下一个是<code>parse()</code>，它在<code>fetch_html()</code>中等待给定的URL，然后从该页面的HTML中提取所有<code>href</code>标签，确保每个标签均有效并对其进行格式化作为绝对路径。</p>
<p>诚然，<code>parse()</code> 的第二部分是阻塞的，但是它由快速的正则表达式匹配组成，并确保将发现的链接设置为绝对路径。</p>
<p>在这种特定情况下，此同步代码应该快速而不起眼。但是请记住，给定协程中的任何行都将阻止其他协程，除非该行使用<code>yield</code>，<code>await</code>或<code>return</code>。如果解析是一个比较繁琐的过程，则可能需要考虑使用[<code>loop.run_in_executor()</code>](<a href="https://docs.python.org/3/library/asyncio-eventloop。" target="_blank" rel="noopener">https://docs.python.org/3/library/asyncio-eventloop。</a><br>html＃executing-code-in-thread-或-process-pools)。</p>
<p>接下来，协程 <code>write()</code>接收一个文件对象和一个URL，然后等待<code>parse()</code>返回一组解析的URL，通过使用<code>aiofiles</code>包将每个URL及其源URL异步写入文件中。 </p>
<p>最后，<code>bulk_crawl_and_write()</code>是脚本协程链的主要入口。它使用单个会话，并为最终从 <code>urls.txt</code> 中读取的每个URL创建一个任务。</p>
<p>以下是一些值得一提的其他要点：</p>
<ul>
<li>默认的 <code>ClientSession</code>具有一个<a href="https://aiohttp.readthedocs.io/en/stable/client_reference.html#connectors" target="_blank" rel="noopener">adapter</a>，最多具有100个打开的连接。要更改此设置，请将<code>asyncio.connector.TCPConnector</code>的实例传递给<code>ClientSession</code>。您还可以基于每个主机指定限制。 </li>
<li>您可以为整个会话和各个请求指定最大<a href="https://aiohttp.readthedocs.io/en/stable/client_quickstart.html#timeouts" target="_blank" rel="noopener">超时</a>。</li>
<li>此脚本还使用了<code>async with</code>，可与<a href="https://www.python.org/dev/peps/pep-0492/#asynchronous-context-managers-and-async-with" target="_blank" rel="noopener">异步上下文管理器</a>一起使用。我没有专门讨论这个概念，因为从同步上下文管理器到异步上下文管理器的过渡非常简单。后者必须定义<code>.__aenter__()</code>和<code>.__aexit__()</code>而不是<code>.__exit__()</code>和<code>.__enter__()</code>。如您所料，<code>async with</code>只能在用<code>async def</code>声明的协程函数中使用。</li>
</ul>
<p>如果您想进一步了解，请在GitHub上查看本教程的<a href="https://github.com/realpython/materials/tree/master/asyncio-walkthrough" target="_blank" rel="noopener">companion files</a>，并附带注释和文档字符串。</p>
<p>这是所有执行过程的结果，因为<code>areq.py</code>在不到一秒钟的时间内获取，解析并保存了9个网址的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ python3 areq.py</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">22</span> DEBUG:asyncio: Using selector: KqueueSelector</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">22</span> INFO:areq: Got response [<span class="number">200</span>] <span class="keyword">for</span> URL: https://www.mediamatters.org/</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">22</span> INFO:areq: Found <span class="number">115</span> links <span class="keyword">for</span> https://www.mediamatters.org/</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">22</span> INFO:areq: Got response [<span class="number">200</span>] <span class="keyword">for</span> URL: https://www.nytimes.com/guides/</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">22</span> INFO:areq: Got response [<span class="number">200</span>] <span class="keyword">for</span> URL: https://www.politico.com/tipsheets/morning-money</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">22</span> INFO:areq: Got response [<span class="number">200</span>] <span class="keyword">for</span> URL: https://www.ietf.org/rfc/rfc2616.txt</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">22</span> ERROR:areq: aiohttp exception <span class="keyword">for</span> https://docs.python.org/<span class="number">3</span>/this-url-will<span class="number">-404.</span>html [<span class="number">404</span>]: Not Found</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">22</span> INFO:areq: Found <span class="number">120</span> links <span class="keyword">for</span> https://www.nytimes.com/guides/</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">22</span> INFO:areq: Found <span class="number">143</span> links <span class="keyword">for</span> https://www.politico.com/tipsheets/morning-money</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">22</span> INFO:areq: Wrote results <span class="keyword">for</span> source URL: https://www.mediamatters.org/</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">22</span> INFO:areq: Found <span class="number">0</span> links <span class="keyword">for</span> https://www.ietf.org/rfc/rfc2616.txt</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">22</span> INFO:areq: Got response [<span class="number">200</span>] <span class="keyword">for</span> URL: https://<span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/s</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">22</span> INFO:areq: Wrote results <span class="keyword">for</span> source URL: https://www.nytimes.com/guides/</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">22</span> INFO:areq: Wrote results <span class="keyword">for</span> source URL: https://www.politico.com/tipsheets/morning-money</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">22</span> INFO:areq: Got response [<span class="number">200</span>] <span class="keyword">for</span> URL: https://www.bloomberg.com/markets/economics</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">22</span> INFO:areq: Found <span class="number">3</span> links <span class="keyword">for</span> https://www.bloomberg.com/markets/economics</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">22</span> INFO:areq: Wrote results <span class="keyword">for</span> source URL: https://www.bloomberg.com/markets/economics</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">23</span> INFO:areq: Found <span class="number">36</span> links <span class="keyword">for</span> https://<span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">23</span> INFO:areq: Got response [<span class="number">200</span>] <span class="keyword">for</span> URL: https://regex101.com/</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">23</span> INFO:areq: Found <span class="number">23</span> links <span class="keyword">for</span> https://regex101.com/</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">23</span> INFO:areq: Wrote results <span class="keyword">for</span> source URL: https://regex101.com/</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">23</span> INFO:areq: Wrote results <span class="keyword">for</span> source URL: https://<span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>/</span><br></pre></td></tr></table></figure>

<p>作为健全性检查，您可以检查输出中的行数。以我的为例，是626，但请注意，这可能会有所波动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wc -l foundurls.txt</span></span><br><span class="line">     626 foundurls.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> head -n 3 foundurls.txt</span></span><br><span class="line">source_url  parsed_url</span><br><span class="line">https://www.bloomberg.com/markets/economics https://www.bloomberg.com/feedback</span><br><span class="line">https://www.bloomberg.com/markets/economics https://www.bloomberg.com/notices/tos</span><br></pre></td></tr></table></figure>

<p><strong>后续步骤</strong>：如果您想要继续提高，请使此网络爬虫递归爬取。您可以使用<a href="https://github.com/aio-libs/aioredis" target="_blank" rel="noopener"><code>aio-redis</code></a>跟踪树中已爬网址的URL以避免两次请求，并使用Python的<code>networkx</code>库连接当中的链接。</p>
<p>发送1000个并发请求到一个小的，毫无戒心的网站是不好的。有一些方法可以限制您在一批中发出的并发请求，例如使用asyncio的<a href="https://stackoverflow.com/q/40836800/7954504" target="_blank" rel="noopener">sempahore</a>对象或使用模式<a href="https://www.artificialworlds.net/blog/2017/05/31/python-3-large-numbers-of-tasks-with-limited-concurrency/" target="_blank" rel="noopener">像这样</a>。如果您不注意此警告，则可能会收到大量的 <code>TimeoutError</code> 异常，最终只会损害您自己的程序。</p>
<h2 id="Async-IO-in-Context"><a href="#Async-IO-in-Context" class="headerlink" title="Async IO in Context"></a>Async IO in Context</h2><p>既然您已经看了很多健壮的代码，那么让我们退一步，考虑一下什么时候异步IO是理想的选择，以及如何进行比较以得出结论或选择其他并发模型。</p>
<h3 id="When-and-Why-Is-Async-IO-the-Right-Choice"><a href="#When-and-Why-Is-Async-IO-the-Right-Choice" class="headerlink" title="When and Why Is Async IO the Right Choice?"></a>When and Why Is Async IO the Right Choice?</h3><p>本教程没有关于异步IO，线程与多进程的扩展论述。但是，了解异步IO什么时候会是三个中的最佳候选者很有用。</p>
<p>异步IO与多进程之间的斗争根本不是一场争斗。实际上，它们可以<a href="https://youtu.be/0kXaLh8Fz3k?t=10m30s" target="_blank" rel="noopener">一起使用</a>。如果您在诸如<code>scikit-learn</code>之类的库中有多个相当统一的CPU绑定任务），多进程应该是显而易见的选择。</p>
<p>如果所有函数都使用阻塞调用，则在每个函数前简单地将 <code>async</code> 放在前面是个坏主意。这实际上可能会减慢您的代码的速度。但是如前所述，异步IO和多进程可以在某些地方<a href="https://youtu.be/0kXaLh8Fz3k?t=10m30s" target="_blank" rel="noopener">共存</a>。</p>
<p>异步IO和线程之间的竞争更为直接。我在导言中提到<strong>线程很难</strong>。全文是，即使在线程似乎易于实现的情况下，由于竞争条件和内存使用等原因，它仍可能导致臭名昭著的无法跟踪的错误。</p>
<p>由于线程是具有有限可用性的系统资源，因此线程也往往不如异步IO那样灵活地扩展。在许多计算机上创建数千个线程将失败，因此我不建议您首先尝试。但<br>创建数千个异步IO任务是完全可行的。</p>
<p>当您有多个IO绑定任务时，异步IO会发挥作用，否则这些任务将通过阻塞IO等待时间来控制，例如：</p>
<ul>
<li>网络IO，无论您的程序是服务器还是客户端</li>
<li>无服务器设计，例如peer-to-peer，多用户网络，如群组聊天室-读/写操作，</li>
<li>您希望模仿“即发即弃”风格，但不必担心在阅读和写入内容时会受到限制</li>
</ul>
<p>不使用它的最大原因是<code>await</code>只支持定义一组特定方法的一组特定对象。如果您想对某个DBMS执行异步读取操作，则不仅需要查找该DBMS的Python包，还需要查找支持<code>async</code> /<code>await</code>语法的包。包含同步调用的协程会阻止其他协程和任务运行。</p>
<p>有关可与<code>async</code>/<code>await</code>一起使用的库的简短列表，请参阅<a href="https://realpython.com/async-io-python/#libraries-that-work-with-asyncawait" target="_blank" rel="noopener">列表</a>。</p>
<h3 id="Async-IO-It-Is-but-Which-One"><a href="#Async-IO-It-Is-but-Which-One" class="headerlink" title="Async IO It Is, but Which One?"></a>Async IO It Is, but Which One?</h3><p>本教程重点介绍异步IO，<code>async</code>/<code>await</code>语法以及如何使用<code>asyncio</code>进行事件循环管理和指定任务。<code>asyncio</code>当然不是唯一的异步IO库。Nathaniel J.Smith 的观察表明：</p>
<blockquote>
<p>[In] a few years, <code>asyncio</code> might find itself relegated to becoming one of those stdlib libraries that savvy developers avoid, like <code>urllib2</code>.</p>
<p>…</p>
<p>What I’m arguing, in effect, is that <code>asyncio</code> is a victim of its own success: when it was designed, it used the best approach possible; but since then, work inspired by <code>asyncio</code> – like the addition of <code>async</code>/<code>await</code> – has shifted the landscape so that we can do even better, and now <code>asyncio</code> is hamstrung by its earlier commitments. <a href="https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/" target="_blank" rel="noopener">(Source)</a></p>
</blockquote>
<p>为此，虽然具有不同的API和不同的方法，但可以执行<code>asyncio</code>功能的一些有名的替代方法有<a href="https://github.com/dabeaz/curio" target="_blank" rel="noopener"><code>curio</code></a>和<a href="https://github.com/python-trio/trio" target="_blank" rel="noopener"><code>trio</code> </a>。我个人认为，如果您要构建大小适中，简单易用的程序，仅使用<code>asyncio</code>就足够了并且易于理解，并且可以避免在Python标准库之外添加其他大型依赖项。</p>
<p>但是，一定要检查一下<code>curio</code>和<code>trio</code>这两个库，您可能会发现它们以一种对用户来说更直观的方式完成了相同的工作。这里介绍的许多与包无关的概念也渗透到其他异步IO软件包中。</p>
<h2 id="Odds-and-Ends"><a href="#Odds-and-Ends" class="headerlink" title="Odds and Ends"></a>Odds and Ends</h2><p>在接下来的几节中，将会向您介绍<code>asyncio</code>和<code>async</code>/<code>await</code>的其他部分，这些部分到目前为止还没有很好地融入本教程，但是对于构建和理解完整的程序仍然很重要。</p>
<h3 id="Other-Top-Level-asyncio-Functions"><a href="#Other-Top-Level-asyncio-Functions" class="headerlink" title="Other Top-Level asyncio Functions"></a>Other Top-Level <code>asyncio</code> Functions</h3><p>除了<code>asyncio.run()</code>之外，您还看到了其他一些包级的功能，例如<code>asyncio.create_task()</code>和<code>asyncio.gather()</code>。您可以使用<code>create_task()</code>调度协程对象的执行，然后使用<code>asyncio.run()</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coro</span><span class="params">(seq)</span> -&gt; list:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""'IO' wait time is proportional to the max element."""</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> asyncio.sleep(max(seq))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> list(reversed(seq))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="comment"># This is a bit redundant in the case of one task</span></span><br><span class="line"><span class="meta">... </span>    <span class="comment"># We could use `await coro([3, 2, 1])` on its own</span></span><br><span class="line"><span class="meta">... </span>    t = asyncio.create_task(coro([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]))  <span class="comment"># Python 3.7+</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> t</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">f't: type <span class="subst">&#123;type(t)&#125;</span>'</span>)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">f't done: <span class="subst">&#123;t.done()&#125;</span>'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = asyncio.run(main())</span><br><span class="line">t: type &lt;<span class="class"><span class="keyword">class</span> '<span class="title">_asyncio</span>.<span class="title">Task</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">t</span> <span class="title">done</span>:</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这种模式有一个精妙之处：如果您不在<code>main()</code>中 <code>await t</code>，则可能会在<code>main()</code>本身已完成之前发出提示。因为<code>asyncio.run(main())</code><a href="https://github.com/python/cpython/blob/7e18deef652a9d413d5dbd19d61073ba7eb5460e/Lib/asyncio/runners.py#L43" target="_blank" rel="noopener">调用<code>loop.run_until_complete(main())</code></a>，事件循环仅仅关注（没有 <code>await t</code> 存在）<code>main()</code>是否完成，而不关注在<code>main()</code>中创建的任务是否完成。<br>如果没有<code>await t</code>，则循环的其他任务<a href="https://github.com/python/cpython/blob/7e18deef652a9d413d5dbd19d61073ba7eb5460e/Lib/asyncio/runners.py#L46" target="_blank" rel="noopener">将被取消</a>。如果需要获取当前待处理任务的列表，可以使用<code>asyncio.Task.all_tasks()</code>。 </p>
<p><strong>注意</strong>：<code>asyncio.create_task()</code>是Python 3.7中引入的。在Python 3.6或更低版本中，使用<code>asyncio.ensure_future()</code>代替<code>create_task()</code>。</p>
<p>另外，还有 <code>asyncio.gather()</code>。尽管它没有做任何特别的事情，但是<code>gather()</code>的作用是将一系列协程（futures）巧妙地放入一个单一的 future 中。然后，它返回一个 future 对象，并且，如果您 <code>await asyncio.gather()</code> 并指定多个任务或协程，则您正在等待所有任务或协程完成。这与先前示例中的<code>queue.join()</code>有点相似。<code>gather()</code>的结果将是输入中结果的列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    t = asyncio.create_task(coro([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br><span class="line"><span class="meta">... </span>    t2 = asyncio.create_task(coro([<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>]))  <span class="comment"># Python 3.7+</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Start:'</span>, time.strftime(<span class="string">'%X'</span>))</span><br><span class="line"><span class="meta">... </span>    a = <span class="keyword">await</span> asyncio.gather(t, t2)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'End:'</span>, time.strftime(<span class="string">'%X'</span>))  <span class="comment"># Should be 10 seconds</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">f'Both tasks done: <span class="subst">&#123;all((t.done(), t2.done()))&#125;</span>'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = asyncio.run(main())</span><br><span class="line">Start: <span class="number">16</span>:<span class="number">20</span>:<span class="number">11</span></span><br><span class="line">End: <span class="number">16</span>:<span class="number">20</span>:<span class="number">21</span></span><br><span class="line">Both tasks done: <span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>]]</span><br></pre></td></tr></table></figure>

<p>您可能已经注意到<code>gather()</code>等待传递给它的 Futures 或协程的结果集。或者，您可以遍历<code>asyncio.as_completed()</code>以按完成顺序获取任务完成时的任务。<br>该函数返回一个迭代器，该迭代器在完成任务时 yield 任务。下面，<code>coro([3，2，1])</code>的结果将在<code>coro([10，5，0])</code>完成之前可用，而<code>gather()</code>则不是这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    t = asyncio.create_task(coro([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br><span class="line"><span class="meta">... </span>    t2 = asyncio.create_task(coro([<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>]))</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Start:'</span>, time.strftime(<span class="string">'%X'</span>))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> res <span class="keyword">in</span> asyncio.as_completed((t, t2)):</span><br><span class="line"><span class="meta">... </span>        compl = <span class="keyword">await</span> res</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">f'res: <span class="subst">&#123;compl&#125;</span> completed at <span class="subst">&#123;time.strftime(<span class="string">"%X"</span>)&#125;</span>'</span>)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'End:'</span>, time.strftime(<span class="string">'%X'</span>))</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">f'Both tasks done: <span class="subst">&#123;all((t.done(), t2.done()))&#125;</span>'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = asyncio.run(main())</span><br><span class="line">Start: <span class="number">09</span>:<span class="number">49</span>:<span class="number">07</span></span><br><span class="line">res: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] completed at <span class="number">09</span>:<span class="number">49</span>:<span class="number">10</span></span><br><span class="line">res: [<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>] completed at <span class="number">09</span>:<span class="number">49</span>:<span class="number">17</span></span><br><span class="line">End: <span class="number">09</span>:<span class="number">49</span>:<span class="number">17</span></span><br><span class="line">Both tasks done: <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>最后，您可能还会看到<code>asyncio.ensure_future()</code>。您几乎不需要它，因为它是一个较低级的管道API，并在很大程度上被稍后介绍的<code>create_task()</code>所取代。</p>
<h3 id="The-Precedence-of-await"><a href="#The-Precedence-of-await" class="headerlink" title="The Precedence of await"></a>The Precedence of <code>await</code></h3><p>尽管它们的行为有些相似，但是关键字<code>await</code> 的优先级明显高于<code>yield</code>。这意味着，由于绑定更为紧密，在许多情况下，您需要在<code>yield from</code>语句中使用括号，而在类似的 <code>await</code> 语句中则不需要。有关更多信息，请参阅PEP 492中的<a href="https://www.python.org/dev/peps/pep-0492/#examples-of-await-expressions" target="_blank" rel="noopener">await表达式示例</a>。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>现在，您已经可以使用<code>async</code>/<code>await</code>以及由此构建的库。以下是您所介绍内容的回顾：</p>
<ul>
<li>异步IO作为与语言无关的模型，以及通过让协程彼此间接通信来实现并发的方式</li>
<li>Python新的<code>async</code>和<code>await</code>关键字的细节，标记和定义协程</li>
<li><code>asyncio</code>，Python包，提供运行和管理协程的API</li>
</ul>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Python, async, await" >
    <span class="tag-code">Python, async, await</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2020/06/22/2020-06-22-%E8%B7%B3%E8%A1%A8/">
        <span class="nav-arrow">← </span>
        
          跳表
        
      </a>
    
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Setting-Up-Your-Environment"><span class="toc-nav-text">Setting Up Your Environment</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#The-10-000-Foot-View-of-Async-IO"><span class="toc-nav-text">The 10,000-Foot View of Async IO</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Where-Does-Async-IO-Fit-In"><span class="toc-nav-text">Where Does Async IO Fit In?</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Async-IO-Explained"><span class="toc-nav-text">Async IO Explained</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Async-IO-Is-Not-Easy"><span class="toc-nav-text">Async IO Is Not Easy</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#The-asyncio-Package-and-async-await"><span class="toc-nav-text">The asyncio Package and async&#x2F;await</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#The-async-await-Syntax-and-Native-Coroutines"><span class="toc-nav-text">The async&#x2F;await Syntax and Native Coroutines</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#The-Rules-of-Async-IO"><span class="toc-nav-text">The Rules of Async IO</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Async-IO-Design-Patterns"><span class="toc-nav-text">Async IO Design Patterns</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Chaining-Coroutines"><span class="toc-nav-text">Chaining Coroutines</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Using-a-Queue"><span class="toc-nav-text">Using a Queue</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Async-IO’s-Roots-in-Generators"><span class="toc-nav-text">Async IO’s Roots in Generators</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Other-Features-async-for-and-Async-Generators-Comprehensions"><span class="toc-nav-text">Other Features: async for and Async Generators + Comprehensions</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#The-Event-Loop-and-asyncio-run"><span class="toc-nav-text">The Event Loop and asyncio.run()</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#A-Full-Program-Asynchronous-Requests"><span class="toc-nav-text">A Full Program: Asynchronous Requests</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Async-IO-in-Context"><span class="toc-nav-text">Async IO in Context</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#When-and-Why-Is-Async-IO-the-Right-Choice"><span class="toc-nav-text">When and Why Is Async IO the Right Choice?</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Async-IO-It-Is-but-Which-One"><span class="toc-nav-text">Async IO It Is, but Which One?</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Odds-and-Ends"><span class="toc-nav-text">Odds and Ends</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Other-Top-Level-asyncio-Functions"><span class="toc-nav-text">Other Top-Level asyncio Functions</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#The-Precedence-of-await"><span class="toc-nav-text">The Precedence of await</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Conclusion"><span class="toc-nav-text">Conclusion</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://shanyongbo.github.io/2020/08/28/2020-08-28-Python中的异步IO/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>



  <script>
    var gitmentConfig = "yanm1ng";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "Python中的异步IO",
        owner: "yanm1ng",
        repo: "yanm1ng.github.io",
        oauth: {
          client_id: "0f87e490e00ee3fd87ef",
          client_secret: "4a9d2b148e7971c2201ad12131ce8bf8159ccd2e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  </script>




    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2020 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng" target="_blank" rel="noopener">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>

  </body>
</html>