<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="shan&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      操作系统-并发 | shan
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/css/plugins/gitment.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    
<script src="/js/qrious.js"></script>

  
  
    
<script src="/js/gitment.js"></script>

  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
<meta name="generator" content="Hexo 4.2.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>shan</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>操作系统-并发</h2>
  <p class="post-date">2020-05-31</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>本文为操作系统导论中关于并发部分的读书笔记。其中主要涉及多线程、锁、信号量等相关知识。</p>
<a id="more"></a>

<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>经典观点是一个程序只有一个执行点（一个程序计数器，用来存放要执行的指令），但多线程程序会有多个执行点（多个程序计数器，每个都用于取指令和执行），换个角度看，每个线程类似于独立的进程，只有一点区别：他们<strong>共享地址空间，从而能够访问相同的数据</strong>。</p>
<p> 线程与进程之间的相同点：</p>
<ul>
<li>有一个程序计数器，记录程序从哪里获取指令。</li>
<li>线程切换和进程切换也有类似的上下文切换，对于进程会将状态保存到进程控制块（Process Control Block，PCB），线程需要一个线程控制块（Thread Control Block，TCB）。</li>
</ul>
<p>线程与进程之间的不同点：</p>
<ul>
<li>在上下文切换的过程中，线程相比于进程地址空间保持不变。</li>
<li>线程与进程之间另一个主要区别是栈，在简单的传统进程地址空间模型中，通常位于地址空间的底部；在多进程中，每个线程都有一个栈。如下图中的单线程和多线程的地址空间示例。</li>
</ul>
<img src="/2020/05/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%B9%B6%E5%8F%91/单线程和多线程的地址空间.png" alt="image-20200531212324465" style="zoom:30%;">

<p>上图显示，两个栈跨越了进程的地址空间。因此，所有位于栈上的变量、参数、返回值和其他放在栈上的东西，被放置在有称为线程本地存储的地方，即线程相关的栈。</p>
<p>下面的术语是关于并发代码的：</p>
<ul>
<li><strong>临界区（critical section）</strong>：访问共享资源的一段代码，资源通常是一个变量或者数据结构。</li>
<li><strong>竞态条件（race condition）</strong>：出现在多个执行线程大致同时进入临界区，他们都视图更新共享的数据结构，导致了出现了不希望的结果。</li>
<li><strong>不确定性（indeterminate）</strong>：程序由一个或多个竞态条件组成，程序的输出因运行而异，具体取决于哪个线程在何时运行。这导致不确定性。</li>
<li><strong>互斥（mutual exclusion）</strong>：保证只有一个线程临界区，从而避免出现竞态，并产生确定的程序输出。</li>
</ul>
<h2 id="线程API"><a href="#线程API" class="headerlink" title="线程API"></a>线程API</h2><p><strong>创建线程</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> *(*start_routine)(<span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数有4 个参数：<code>thread</code>、<code>attr</code>、<code>start_routine</code> 和<code>arg</code>。</p>
<p>第一个参数 thread 是指向<code>pthread_t</code> 结构类型的指针，我们将利用这个结构与该线程交互，因此需要将它传入pthread_create()，以便将它初始化。</p>
<p>第二个参数 <code>attr</code> 用于指定该线程可能具有的任何属性。</p>
<p>第三个<code>start_routine</code>参数用于决定线程应该在哪个函数中运行，在C 中，我们把它称为一个函数指针（function pointer）。</p>
<p>第四个参数<code>arg</code> 就是要传递给线程开始执行的函数的参数。</p>
<p><strong>等待线程完成</strong>：</p>
<p>调用函数 <code>pthread_join()</code> ，该函数有两个参数，第一个参数为 <code>pthread_t</code> 类型，用于指定要等待的线程。第二个参数是一个指针，指向你希望得到的返回值。</p>
<p><strong>锁</strong>：</p>
<p>可以提供互斥进入临界区的那些函数，这方面最基本的函数是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>条件变量</strong>：当线程之间必须发生某种信号时，如果一个线程在等待另一个线程继续执行默写操作，条件变量就很有用，其主要函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>



<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>通过对并发的介绍，我们看到了并发编程的一个基本问题：我们希望原子式执行一系列指令，但由于单处理器上的中断，很难做到这点。我们采用锁这种凡是，来解决这一问题。</p>
<h2 id="锁的基本思想"><a href="#锁的基本思想" class="headerlink" title="锁的基本思想"></a>锁的基本思想</h2><p>锁就是一个变量，因此我们需要声明一个某种类型的<strong>锁变量（lock variable）</strong>，才能使用。这个锁变量保存了锁在某一时刻的状态，要么是<strong>可用的（available）</strong>，表示没有线程持有锁，要么是<strong>被占用的（acquired）</strong>，表示有一个线程持有锁，正处于临界区。我们也可以保存其他的信息，比如持有锁的线程，或者请求获取锁的线程队列，但这些信息会被隐藏起来，锁的使用者不会发现。</p>
<p><strong>锁为程序员提供了最小程度的调度控制</strong>。我们把线程视为程序员创建的实体，但是被操作系统调度，具体方式由操作系统做出选择。锁让程序员获得一些控制权。通过给临界区加锁，可以保证临界区内只有一个线程活跃。锁将原本由操作系统调度的混乱状态变得更为可控。</p>
<h2 id="Pthread-锁"><a href="#Pthread-锁" class="headerlink" title="Pthread 锁"></a>Pthread 锁</h2><p>POSIX 库将锁称为<strong>互斥量（mutex）</strong>，它们被用来提供线程之间的互斥。我们能用不同的锁来保护不同的变量，这样可以增加并发：不同于任何临界区都使用同一个大锁（粗粒度锁策略），通常大家会用不同的锁保护不同的数据和结构，从而允许更多的线程进入临界区（细粒度方案）。</p>
<h2 id="实现一个锁"><a href="#实现一个锁" class="headerlink" title="实现一个锁"></a>实现一个锁</h2><p>上面对锁已经有了一定的理解，那么如何实现一个锁，需要什么样的硬件支持？什么样的操作系统的支持？</p>
<p>各种计算机体系结构的指令集都增加了一些不同的硬件原语，我们不研究这些指令是如何实现的，只研究如何使用它们来实现像锁这样的互斥原语。我们也<br>会研究操作系统如何发展完善，支持实现成熟复杂的锁库。</p>
<h3 id="锁的标准"><a href="#锁的标准" class="headerlink" title="锁的标准"></a>锁的标准</h3><p>为了实现锁，我们应该设立一些标准：</p>
<ul>
<li><strong>提供互斥（mutual exclusion）</strong>，最基本的，锁是否有效，能够阻止多个线程进入临界区。</li>
<li><strong>公平性（fairness）</strong>，让每个竞争的线程有公平的机会抢到锁。</li>
<li><strong>性能（performance）</strong>，使用锁之后增加的时间开销最小。</li>
</ul>
<h3 id="互斥的解决方案"><a href="#互斥的解决方案" class="headerlink" title="互斥的解决方案"></a>互斥的解决方案</h3><ul>
<li><p><strong>在临界区关闭中断</strong>，这个解决方案是为但处理器系统开发的。这种方案优点是简单，缺点很多：</p>
<ol>
<li>一个贪婪的程序在它开始就调用lock()，从而独占处理器。</li>
<li>不支持多处理器。</li>
<li>关闭中断导致中断丢失，可能会导致严重的系统问题。</li>
<li>效率太低。</li>
</ol>
</li>
<li><p><strong>测试并设置指令（test-and-set instruction）</strong>，也叫做<strong>原子交换（atomic exchange）</strong>，这里实现了一种简单的锁：<strong>自旋锁（spin lock）</strong>，利用CPU周期，一直自旋，直到锁可用。在单处理器上，需要抢占式的调度器（preemptive scheduler，即不断通过时钟中断一个线程，运行其他线程）。否则自旋锁在单CPU上无法使用，因为自旋的线程永远不会放弃CPU。优点：这是一个正确的锁，一次只允许一个线程进入临界区。缺点：</p>
<ol>
<li>自旋锁不提供任何公平性的保证。</li>
<li>在单CPU的情况下，性能开销十分巨大，假设一个线程持有锁进入临界区时被抢占。调度器可能会运行其他每一个线程，而其他线程都在竞争锁，都会在放弃CPU 之前，自旋一个时间片，浪费CPU 周期。但在多CPU上性能表现不错。</li>
</ol>
</li>
<li><p><strong>比较并交换指令（compare-and-swap，compare-and-exchange (x86)）</strong>：实现自旋锁的情况下，与上面类似。</p>
</li>
<li><p><strong>链接的加载（load-link）和条件式的存储（store-conditional）</strong>：可以用这两个指令来配合使用实现并发结构。链接的加载指令和典型加载指令类似，都是从内存中取出值存入一个寄存器。关键区别来自条件式存储（store-conditional）指令，只有上一次加载的地址在期间都没有更新时，才会成功，（同时更新刚才链接的加载的地址的值）。成功时，条件存储返回1，并将 ptr 指的值更新为value。失败时，返回0，并且不会更新值。</p>
</li>
<li><p><strong>获取并增加指令（fetch-and-add）</strong>：他能原子的返回特定地址的旧值，并让该值自增一。我们用这个特性，实现一个ticket锁。实现如下面代码所示，此法保证所有的线程都能抢到锁。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"># 实现ticket锁</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FetchAndAdd</span><span class="params">(<span class="keyword">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *ptr;</span><br><span class="line">    *ptr = old + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ticket;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">turn</span>;</span><br><span class="line">    &#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">    lock-&gt;<span class="built_in">turn</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">    <span class="keyword">while</span> (lock-&gt;<span class="built_in">turn</span> != myturn)</span><br><span class="line">        ; <span class="comment">// spin</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    FetchAndAdd(&amp;lock-&gt;<span class="built_in">turn</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在要自旋的时候，放弃CPU</strong>，这样可以节省CPU的开销。</p>
</li>
<li><p><strong>使用队列，让休眠替代自旋</strong>。将之前的测试并设置和等待队列结合，实现了一个更高性能的锁。其次，我们通过队列来控制谁会获得锁，避免饿死。</p>
</li>
<li><p><strong>两阶段锁（two-phase lock）</strong>，在需要快速释放锁的场景内很有用。</p>
</li>
</ul>
<h2 id="基于锁的并发数据结构"><a href="#基于锁的并发数据结构" class="headerlink" title="基于锁的并发数据结构"></a>基于锁的并发数据结构</h2><p>对于特定数据结构，如何加锁才能让该结构功能正确？如何对该数据结构加锁，才能保证高性能，即并发访问？</p>
<p>并发链表、并发队列、并发散列表等结构的实现见操作系统导论第二十九章部分。下面是这些部分的简述</p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>没有同步机制的计数器代码很简单，但是线程安全的并且保持高性能的可扩展计数器已经研究多年了。</p>
<p><strong>懒惰计数器</strong>是最近研究提出的，其基本思想是：<strong>懒惰计数器通过多个局部计数器和一个全局计数器来实现一个逻辑计数器，其中每个CPU核心有一个局部计数器</strong>。如果核心上的线程想增加计数器，那就增加它的局部计数器，为了保持全局计数器的更新，局部值会定期转移给全局计数器，方法是获取全局锁，让全局计数器加上局部计数器的值，然后把局部计数器置零。这种局部转全局的频度，取决于一个阈值，阈值越小，懒惰计数器则趋近于非扩展计数器。阈值越大，扩展性越强，全局计数器与实际计数的偏差越大。</p>
<p>下面为懒惰计数器的基本实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMCPUS 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> global;            <span class="comment">// global count</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> glock;                <span class="comment">// global lock</span></span><br><span class="line">    <span class="keyword">int</span> local[NUMCPUS];    <span class="comment">// local count (per cpu)</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> llock[NUMCPUS];    <span class="comment">// ... and locks</span></span><br><span class="line">    <span class="keyword">int</span> threshold;            <span class="comment">// update frequency</span></span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init: record threshold, init locks, init values</span></span><br><span class="line"><span class="comment">// of all local counts and global count</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span> *c, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">    c-&gt;threshold = threshold;</span><br><span class="line"></span><br><span class="line">    c-&gt;global = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;c-&gt;glock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMCPUS; i++) &#123;</span><br><span class="line">        c-&gt;local[i] = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_init(&amp;c-&gt;llock[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update: usually, just grab local lock and update local amount</span></span><br><span class="line"><span class="comment">// once local count has risen by 'threshold', grab global</span></span><br><span class="line"><span class="comment">// lock and transfer local values to it</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">counter_t</span> *c, <span class="keyword">int</span> threadID, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;c-&gt;llock[threadID]);</span><br><span class="line">    c-&gt;local[threadID] += amt;        <span class="comment">// assumes amt &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;local[threadID] &gt;= c-&gt;threshold) &#123;    <span class="comment">// transfer to global</span></span><br><span class="line">        pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">        c-&gt;global += c-&gt;local[threadID];</span><br><span class="line">        pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">        c-&gt;local[threadID] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;c-&gt;llock[threadID]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get: just return global amount (which may not be perfect)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">    <span class="keyword">int</span> val = c-&gt;global;</span><br><span class="line">    pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">    <span class="keyword">return</span> val;    <span class="comment">// only approximate!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="并发链表"><a href="#并发链表" class="headerlink" title="并发链表"></a>并发链表</h3><p>下面为并发链表的代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="keyword">node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">node_t</span> *head;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">&#125; <span class="keyword">list_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Init</span><span class="params">(<span class="keyword">list_t</span> *L)</span> </span>&#123;</span><br><span class="line">    L-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    pthread_mutex_init(&amp;L-&gt;lock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(<span class="keyword">list_t</span> *L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">node_t</span> *<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"malloc"</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span>-&gt;key = key;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = L-&gt;head;</span><br><span class="line">    L-&gt;head = <span class="keyword">new</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Lookup</span><span class="params">(<span class="keyword">list_t</span> *L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">node_t</span> *curr = L-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;key == key) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的代码在插入函数入口处获取锁，结束时释放锁，但是如果malloc失败会存在问题，代码在插入失败时必须释放锁。因此我们需要对代码进行改动，保持并发的正确，在失败的时候也释放锁。</p>
<p>这里调整的代码目的是为了让获取和释放锁只环绕插入代码的真正临界区。另一个改动是查找，跳出主查找循环，到单一的返回路径，这样降低了不小心忘记释放锁的可能性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(<span class="keyword">list_t</span> *L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">node_t</span> *<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"malloc"</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span>-&gt;key = key;</span><br><span class="line">    pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = L-&gt;head;</span><br><span class="line">    L-&gt;head = <span class="keyword">new</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Lookup</span><span class="params">(<span class="keyword">list_t</span> *L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rv = <span class="number">-1</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">node_t</span> *curr = L-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;key == key) &#123;</span><br><span class="line">            rv = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这个链表的扩展性不好，这里有种方法增加到链表中，理论上增加了并发性，这种技术称为<strong>过手锁（hand-over-hand locking）</strong>，也叫<strong>锁耦合（lock coupling）</strong>，原理是：每个节点都有一个锁，替代之前整个链表一个锁，遍历链表时，首先抢占下一个节点的锁，然后释放当前节点的锁。从理论上可以增加并发，但是由于对于锁的消耗开销巨大，很难比单锁的方法快。</p>
<h3 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h3><p>根据队列的数据结构，分为队列头和队列尾，在这两个特殊的位置加两把锁，使得入队操作和出队操作可以并发执行，因为入队只访问tail锁，出队只访问head锁。在下面的例子中添加了一个假节点，该节点分开了头和尾的操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">node_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;<span class="keyword">node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">node_t</span> *head;</span><br><span class="line">    <span class="keyword">node_t</span> *tail;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> headLock;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> tailLock;</span><br><span class="line">&#125; <span class="keyword">queue_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue_Init</span><span class="params">(<span class="keyword">queue_t</span> *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">node_t</span> *temp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;head = q-&gt;tail = temp;</span><br><span class="line">    pthread_mutex_init(&amp;q-&gt;headLock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;q-&gt;tailLock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue_Enqueue</span><span class="params">(<span class="keyword">queue_t</span> *q, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">node_t</span> *tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">    assert(tmp != <span class="literal">NULL</span>);</span><br><span class="line">    tmp-&gt;value = value;</span><br><span class="line">    tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock(&amp;q-&gt;tailLock);</span><br><span class="line">    q-&gt;tail-&gt;next = tmp;</span><br><span class="line">    q-&gt;tail = tmp;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;tailLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queue_Dequeue</span><span class="params">(<span class="keyword">queue_t</span> *q, <span class="keyword">int</span> *value)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;q-&gt;headLock);</span><br><span class="line">    <span class="keyword">node_t</span> *tmp = q-&gt;head;</span><br><span class="line">    <span class="keyword">node_t</span> *newHead = tmp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (newHead == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;q-&gt;headLock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *value = newHead-&gt;value;</span><br><span class="line">    q-&gt;head = newHead;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;headLock);</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><p>上面学习了锁的概念以及如何通过硬件和操作系统支持的正确组合来实现锁。然而在很多情况下，线程需要检查某一条件满足之后，才会集训运行，如父线程需要检查子线程他是否执行完毕（join）。</p>
<p>多线程程序中，一个线程等待某些条件是很常见的。简单的方案是自旋直到条件满足，这是极其低效的，某些情况下甚至是错误的。那么，线程应该如何等待一个条件？</p>
<p>线程可以使用<strong>条件变量（condition variable）</strong>，来等待一个条件变成真。条件变量是一个显式队列，当某些执行状态不满足时，线程可以把自己加入队列，等待该条件。另外某个线程，当它改变了上述状态时，就可以唤醒一个或多个等待线程。</p>
<p>条件变量有两种相关操作：<strong>wait() 和 signal()</strong>，线程要睡眠的时候调用wait()，当线程想要唤醒等待在某个条件变量上的睡眠线程时，调用signal()。</p>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者/消费者问题"></a>生产者/消费者问题</h2><p><strong>生产者/消费者问题，也叫做有界缓冲区（bounded buffer）问题</strong>。假设有一个或多个生产者和一个或多个消费者线程，生产者把生产的数据放入缓冲区，消费者从缓冲区取走数据项，以某种方式消费。</p>
<p>因为有界缓冲区是共享资源，所以我们必须通过同步机制来访问它，以免产生竞态条件。</p>
<p>增加更多缓冲区槽位，这样在睡眠之前，可以生产多个值。同样，睡眠之前可以消费多个值。单个生产者和消费者时，这种方案因为上下文切换少，提高了效率。多个生产者和消费者时，它甚至支持并发生产和消费，从而提高了并发。下节将详细介绍这个问题。</p>
<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>本节的问题是如何使用信号量代替锁和条件变量？什么是信号量？什么是二值信号量？用锁和条件变量来实现信号量是否简单？不用锁和条件变量，如何实现信号量？</p>
<h2 id="信号量的定义"><a href="#信号量的定义" class="headerlink" title="信号量的定义"></a>信号量的定义</h2><p><strong>信号量是一个有整数值的对象</strong>，可以用两个函数来操作它，在POSIX标准中，是<code>sem_wait()</code> 和 <code>sem_post()</code>。因为信号量的初始值能够决定其行为，所以首先要初始化信号量，才能调用其他函数与之交互。</p>
<p>信号量接口的几个需要说明的方面：</p>
<ol>
<li><code>sem_wait()</code> 要么立刻返回，要么会让调用线程挂起，直到之后的一个post操作。也可能多个调用线程都调用<code>sem_wait()</code>，因此都在队列中等待被唤醒。</li>
<li><code>sem_post()</code>并没有等待某些条件满足，它直接增加信号量的值，如果有等待线程，唤醒其中一个。</li>
<li>当信号量的值为负数时，这个值就是等待线程的个数。</li>
</ol>
<p><strong>二值信号量（锁）</strong>：使用信号量来实现锁，因为锁只有两个状态，所以这种用法有时也叫做二值信号量（binary semaphore）。其使用方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> m;</span><br><span class="line">sem_init(&amp;m, <span class="number">0</span>, X); <span class="comment">//根据不同的需求，X的值不同</span></span><br><span class="line"></span><br><span class="line">sem_wait(&amp;m);</span><br><span class="line"><span class="comment">//竞态条件，加锁部分</span></span><br><span class="line">sem_post(&amp;m);</span><br></pre></td></tr></table></figure>





<h2 id="信号量作为条件变量"><a href="#信号量作为条件变量" class="headerlink" title="信号量作为条件变量"></a>信号量作为条件变量</h2><p>信号量也可以用在一个线程暂停执行，等待某一条件成立的场景。因为等待线程在等待某些条件发生变化，所以我们将信号量作为<strong>条件变量（condition variable）</strong>。</p>
<p>父线程调用<code>sem_wait()</code>，子线程调用<code>sem_post()</code>，父线程应该等待子线程的完成，这时需要将信号量的初始值设置为0，才能发挥应有的功能，具体情况如下：</p>
<ul>
<li>第一种情况，父线程创建了子线程，但子线程没有运行，这种情况下，父线程调用<code>sem_wait()</code>会先于子线程调用<code>sem_post()</code>，我们希望父线程等待子线程运行，故当初始值为0时，父线程运行将信号量减为-1，等待睡眠；子线程运行的时候，调用<code>sem_post()</code>，信号量增加为0，唤醒父线程，父线程从<code>sem_wait()</code> 返回，完成该程序。</li>
<li>第二种情况是，子线程在父线程调用<code>sem_wait()</code>之前结束，在这种情况下，子线程会先调用<code>sem_post()</code>，将信号量从0增加到1，然后当父线程运行时，会调用<code>sem_wait()</code>，发现信号量值为1，于是父线程将信号量从1减到0，没有等待，直接从<code>sem_wait()</code>返回执行。</li>
</ul>
<p>相关演示的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">child</span><span class="params">(<span class="keyword">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child\n"</span>);</span><br><span class="line">    sem_post(&amp;s);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>;</span><br><span class="line">    sem_init(&amp;s, <span class="number">0</span>, X);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: begin\n"</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> c;</span><br><span class="line">    pthread_create(c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">    sem_wait(&amp;s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: ned\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="生产者-消费者问题-1"><a href="#生产者-消费者问题-1" class="headerlink" title="生产者/消费者问题"></a>生产者/消费者问题</h2><p>这个问题详细描述参考上一章，可以利用二值信号量加锁进行解决。</p>
<p>首先用empty和full这两个信号量表示缓冲区空或者满（假设MAX=1，情况复合预期）。</p>
<p>当MAX &gt; 1时，put() 和 get() 会产生竞态条件，此时用二值信号量对产生竞态的操作进行加锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">buffer</span>[MAX];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">fill</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> use = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="built_in">buffer</span>[<span class="built_in">fill</span>] = value;</span><br><span class="line">    <span class="built_in">fill</span> = (<span class="built_in">fill</span> + <span class="number">1</span>) % MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="built_in">buffer</span>[use];</span><br><span class="line">    user = (use + <span class="number">1</span>) % MAX;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">sem_t</span> empty;</span><br><span class="line"><span class="keyword">sem_t</span> full;</span><br><span class="line"><span class="keyword">sem_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        sem_wait(&amp;empty);</span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        <span class="built_in">put</span>(i);</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">        sem_post(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        sem_wait(&amp;empty);</span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="built_in">get</span>();</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">        sem_post(&amp;full);</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"%d\n"</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    sem_inti(&amp;empty, <span class="number">0</span>, MAX);</span><br><span class="line">    sem_init(&amp;full, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="读者-写者锁"><a href="#读者-写者锁" class="headerlink" title="读者-写者锁"></a>读者-写者锁</h2><p>对更加灵活的锁定原语的渴望，它承认不同的数据结构范文可能需要不同类型的锁。如一个并发链表有很多插入和查找操作，查找操作只是读取该结构，只要没有进行插入操作，就可以并发的执行多个查找操作。<strong>读者-写者锁（reader-writer lock）</strong>就是用来完成这种操作的。</p>
<p>如果摸个线程要更新数据结构，需要调用<code>rwlock_acquire_lock()</code> 获得写锁，调用<code>rwlock_release_writelock()</code> 释放锁。内部通过一个<code>writelock</code>的信号量保证只有一个写者锁进入临界区，从而更新数据结构，其实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rwlock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">sem_t</span> lock;</span><br><span class="line">    <span class="keyword">sem_t</span> writelock;</span><br><span class="line">    <span class="keyword">int</span> readers;</span><br><span class="line">&#125; <span class="keyword">rwlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_init</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123;</span><br><span class="line">    rw-&gt;readers = <span class="number">0</span>;</span><br><span class="line">    sem_init(&amp;rw-&gt;lock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;rw-&gt;writelock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_acquire_readlock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123;</span><br><span class="line">    sem_wait(&amp;rw-&gt;lock);</span><br><span class="line">    rw-&gt;readers++;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;rw-&gt;writelock);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;rw-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_release_readlock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span></span>&#123;</span><br><span class="line">    sem_wait(&amp;rw-&gt;lock);</span><br><span class="line">    rw-&gt;readers--;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers==<span class="number">0</span>)&#123;</span><br><span class="line">        sem_post(&amp;rw-&gt;writelock);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;rw-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_acquire_writelock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123;</span><br><span class="line">    sem_wait(&amp;rw-&gt;writelock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_release_writelock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123;</span><br><span class="line">    sem_post(&amp;rw-&gt;writelock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="如何实现信号量"><a href="#如何实现信号量" class="headerlink" title="如何实现信号量"></a>如何实现信号量</h2><p>可以利用底层的同步原语锁和条件变量来实现自己的信号量，如下代码实现了一个叫<code>Zemaphore</code>的信号量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Zem_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">&#125; Zem_t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Zem_init</span><span class="params">(Zem_t *s, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    s-&gt;value = value;</span><br><span class="line">    Cond_init(&amp;s-&gt;cond);</span><br><span class="line">    Mutex_init(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Zem_wait</span><span class="params">(Zem_t *s)</span></span>&#123;</span><br><span class="line">    Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line">    <span class="keyword">while</span> (s-&gt;value &lt;= <span class="number">0</span>)</span><br><span class="line">        Cond_wait(&amp;s-&gt;cond, &amp;s-&gt;lock);</span><br><span class="line">    s-&gt;value--;</span><br><span class="line">    Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Zem_post</span><span class="params">(Zem_t *s)</span> </span>&#123;</span><br><span class="line">    Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;value++;</span><br><span class="line">    Cond_signal(&amp;s-&gt;cond);</span><br><span class="line">    Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="常见并发问题"><a href="#常见并发问题" class="headerlink" title="常见并发问题"></a>常见并发问题</h1><p>在复杂的并发程序中，有死锁和非死锁这两种类型的缺陷，主要集中在四个著名的开源应用：MySQL、Apache、Mozilla、OpenOffice等。</p>
<h2 id="非死锁缺陷"><a href="#非死锁缺陷" class="headerlink" title="非死锁缺陷"></a>非死锁缺陷</h2><p>非死锁缺陷占了并发问题的大多数，我们主要讨论两种：<strong>违反原子性（atomicity violation）</strong>缺陷和<strong>错误顺序（order violation）</strong>缺陷。</p>
<p><strong>违反原子性缺陷</strong>：违反了多次内存访问中预期可串行性，即代码段本意是原子的，但在执行中却没有强制实现原子性。</p>
<p><strong>违反顺序缺陷</strong>：两个内存访问的预期顺序被打破了，即A应该在B之前执行，但是实际运行中却不是这个顺序。</p>
<h2 id="死锁缺陷"><a href="#死锁缺陷" class="headerlink" title="死锁缺陷"></a>死锁缺陷</h2><p><strong>死锁（deadlock）</strong>是一种在许多复杂并发系统中出现的经典问题。例如，当线程1 持有锁L1，正在等待另外一个锁L2，而线程2 持有锁L2，却在等待锁L1 释放时，死锁就产生了。</p>
<p><strong>死锁发生的原因</strong>：</p>
<ul>
<li>在大型代码库里，组件之间会有复杂的依赖。</li>
<li>另一个原因是封装（encapsulation）。一般封装的模块会让软件开发更容易，一般会隐藏细节，这很容易导致死锁的发生。</li>
</ul>
<p><strong>死锁产生的条件</strong>：</p>
<ul>
<li>互斥：线程对于需要的资源进行互斥的访问；</li>
<li>持有并等待：线程持有了资源，同时又在等待其他的资源；</li>
<li>非抢占式：线程获得的资源，不能被抢占。</li>
<li>循环等待：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的。</li>
</ul>
<p><strong>死锁预防</strong>：</p>
<ul>
<li>让代码不产生循环等待，即获取锁时，提供一个<strong>全序（total ordering）</strong>。但锁的全序可能很难做到，因此，<strong>偏序（partial</strong><br>  <strong>ordering）</strong>可能是一种有用的方法，安排锁的获取并避免死锁。</li>
<li>可以通过<strong>原子抢锁</strong>避免持有并等待的导致的死锁。</li>
<li>在获取锁时，先进行尝试获取。</li>
<li>通过强大的硬件指令，构造出不需要锁的数据结构，避免互斥问题导致的死锁。</li>
</ul>
<p><strong>通过调度避免死锁</strong>：了解全局信息，包括不同线程在运行中对锁的需求，从而使得后续的调度能够避免产生死锁。</p>
<p>允许死锁偶尔发生，检查到死锁在采取行动。</p>
<h1 id="基于事件的并发"><a href="#基于事件的并发" class="headerlink" title="基于事件的并发"></a>基于事件的并发</h1><p>基于事件的并发（event-based concurrency）主要针对两方面的问题：</p>
<ol>
<li>多线程应用中，正确处理并发很有难度。</li>
<li>开发人员无法控制多线程在某一时刻的调度。</li>
</ol>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>主循环等待某些事件的发生，然后依次处理这些发生的事件，处理事件的代码叫做时间处理程序（event handler），处理程序在处理一个事件时，它是系统中发生的唯一活动。因此，调度就是决定接下来处理哪个事件，而这个结构称为<strong>事件循环（event loop）</strong>。其伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;</span><br><span class="line">    events &#x3D; getEvents();</span><br><span class="line">    for (e in events)</span><br><span class="line">        processEvent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这也带来一个更大的问题：基于事件的服务器如何决定哪个事件发生，尤其是对于网络和磁盘I/O？具体来说，事件服务器如何确定是否有它的消息已经到达？</p>
<h3 id="select-介绍"><a href="#select-介绍" class="headerlink" title="select() 介绍"></a>select() 介绍</h3><p>大多数操作系统提供了基本的API来解决如何接收事件的问题，如<strong><code>select()</code></strong> 或者<strong><code>poll()</code></strong>  系统调用。这些接口作用主要是：<strong>检查是否有任何应该关注的进入I/O。</strong>例如网络服务希望检查数据包是否到达。下面以select为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds,</span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set *<span class="keyword">restrict</span> readfds,</span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set *<span class="keyword">restrict</span> writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set *<span class="keyword">restrict</span> errorfds,</span></span></span><br><span class="line"><span class="function"><span class="params">           struct timeval *<span class="keyword">restrict</span> timeout</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>select()</code> 会检查I/O描述符集合，它们的地址通过<code>readfds</code>、<code>writefds</code>和<code>errorfds</code>传入，分别查看它们中的某些描述符是否已经准备好读取，是否准备好写入，或者异常处理等。在每个集合中检查前<code>n fds</code> 个描述符，即检查描述符集合中从<code>0</code> 到<code>nfds-1</code>的描述符，返回时，<code>select()</code> 用给定请求操作准备好的描述符组成的子集替换成给定的描述符集合。<code>select()</code> 返回所有集合中就绪描述符的总数。</p>
<h3 id="select-使用"><a href="#select-使用" class="headerlink" title="select() 使用"></a>select() 使用</h3><p>下面是一个用select() 来查看哪些网络描述符在它们上面有传入的消息的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开一系列的sockets，未展示</span></span><br><span class="line">    <span class="comment">// 主循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        fd_set readFDs;</span><br><span class="line">        FD_ZERO(&amp;readFDs);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 现在为描述符设置位</span></span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">for</span> (fd=minFD; fd &lt; maxFD; fd++)</span><br><span class="line">            FD_SET(fd, &amp;readFDs);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// do the select</span></span><br><span class="line">        <span class="keyword">int</span> rc = select(maxFD+<span class="number">1</span>, &amp;readFDs, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用FD_ISSET()检查哪个有数据</span></span><br><span class="line">        inf fd;</span><br><span class="line">        <span class="keyword">for</span> (fd=minFD; fd &lt; maxFD; fd++)</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(fd, &amp;readFDs))</span><br><span class="line">                processFD(fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化完成后，服务器进入无限循环。在循环内部，它使用<code>FD_ZERO()</code>宏首先清除文件描述符集合，然后使用<code>FD_SET()</code>将所有从<code>minFD</code> 到<code>maxFD</code>的文件描述符包含到集合中。例如，这组描述符可能表示服务器正在关注的所有网络套接字。最后，服务器调用<code>select()</code>来查看哪些连接有可用的数据。然后，通过在循环中使用<code>FD_ISSET()</code>，事件服务器可以查看哪些描述符已准备好数据并处理传入的数据。</p>
<h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><p>现代操作系统引入了新的方法来向磁盘系统发出<strong>异步I/O请求（asynchronous I/O）</strong>。这些接口使得应用程序能够发出I/O请求，并在I/O完成之前立即将控制权返回给调用者，另外加的接口让应用程序能够确定各种I/O是否已经完成。</p>
<p>为了解决需要检查每个I/O是否完成导致的重复性问题，一些系统提供了基于<strong>中断（interrupt）</strong>的方法。此方法使用 <strong>Unix信号（signal）</strong>在异步I/O完成时通知应用程序，从而消除了重复轮询系统的需要。</p>
<p><strong>信号（signal）</strong>：在现在Unix变体中普遍存在，最简单的信号提供了一种与进程进行通信的方式。具体来说，可以将信号传递给应用程序。这样会让应用程序停止当前的任何工作，开始运行<strong>信号处理程序(signal handler)</strong>，即应用程序中默写处理信号的代码。完成后，该进程就恢复其先前的行为。</p>
<p>没有异步I/O的系统中，纯粹基于事件的方法是无法实现的。</p>
<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>基于事件的方法的另一个问题是，这种方法的代码比传统的基于线程的方法更加复杂。其原因如下：当时间处理程序发出异步I/O时，它必须打包一些程序状态，以便下一个时间处理程序在I/O最终完成时使用。这个额外的工作在基于线程的程序中是不需要的，因为程序需要的状态在线程栈中。手工栈管理时基于事件编程的基础。</p>
<p>基于事件的方法当系统从单核CPU转向多核时，它就变得更加复杂了。为了利用多核，事件服务器必须运行多个事件处理程序，发生这种情况时，就会出现常见的同步问题，并且必须采用锁的常用的解决方案。另一个问题是，它不能很好的和某些类型的系统活动集成，如分页。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#操作系统" >
    <span class="tag-code">操作系统</span>
  </a>

  <a href="/tags#并发" >
    <span class="tag-code">并发</span>
  </a>

  <a href="/tags#线程" >
    <span class="tag-code">线程</span>
  </a>

  <a href="/tags#锁" >
    <span class="tag-code">锁</span>
  </a>

  <a href="/tags#信号量" >
    <span class="tag-code">信号量</span>
  </a>

  <a href="/tags#事件循环" >
    <span class="tag-code">事件循环</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2020/05/28/2020-05-28-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84python%E5%AE%9E%E7%8E%B0/">
        <span class="nav-arrow">← </span>
        
          二叉树的python实现
        
      </a>
    
    
      <a class="nav-right" href="/2020/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%8C%81%E4%B9%85%E6%80%A7/">
        
          操作系统-持久性
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#线程"><span class="toc-nav-text">线程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#介绍"><span class="toc-nav-text">介绍</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#线程API"><span class="toc-nav-text">线程API</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#锁"><span class="toc-nav-text">锁</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#锁的基本思想"><span class="toc-nav-text">锁的基本思想</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Pthread-锁"><span class="toc-nav-text">Pthread 锁</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#实现一个锁"><span class="toc-nav-text">实现一个锁</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#锁的标准"><span class="toc-nav-text">锁的标准</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#互斥的解决方案"><span class="toc-nav-text">互斥的解决方案</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#基于锁的并发数据结构"><span class="toc-nav-text">基于锁的并发数据结构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#计数器"><span class="toc-nav-text">计数器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#并发链表"><span class="toc-nav-text">并发链表</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#并发队列"><span class="toc-nav-text">并发队列</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#条件变量"><span class="toc-nav-text">条件变量</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#生产者-消费者问题"><span class="toc-nav-text">生产者&#x2F;消费者问题</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#信号量"><span class="toc-nav-text">信号量</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#信号量的定义"><span class="toc-nav-text">信号量的定义</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#信号量作为条件变量"><span class="toc-nav-text">信号量作为条件变量</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#生产者-消费者问题-1"><span class="toc-nav-text">生产者&#x2F;消费者问题</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#读者-写者锁"><span class="toc-nav-text">读者-写者锁</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#如何实现信号量"><span class="toc-nav-text">如何实现信号量</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#常见并发问题"><span class="toc-nav-text">常见并发问题</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#非死锁缺陷"><span class="toc-nav-text">非死锁缺陷</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#死锁缺陷"><span class="toc-nav-text">死锁缺陷</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#基于事件的并发"><span class="toc-nav-text">基于事件的并发</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#事件循环"><span class="toc-nav-text">事件循环</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#select-介绍"><span class="toc-nav-text">select() 介绍</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#select-使用"><span class="toc-nav-text">select() 使用</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#异步I-O"><span class="toc-nav-text">异步I&#x2F;O</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#状态管理"><span class="toc-nav-text">状态管理</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://shanyongbo.github.io/2020/05/31/操作系统-并发/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>



  <script>
    var gitmentConfig = "shan";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "操作系统-并发",
        owner: "shan",
        repo: "shan.github.io",
        oauth: {
          client_id: "0f87e490e00ee3fd87ef",
          client_secret: "4a9d2b148e7971c2201ad12131ce8bf8159ccd2e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  </script>




    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2020 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng" target="_blank" rel="noopener">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>

  </body>
</html>